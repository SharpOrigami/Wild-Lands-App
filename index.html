<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wild West Card Game (Standalone)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,400&family=Special+Elite&family=Rye&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --paper-bg: #f4f1ea;
            --ink-main: #3a3a3a;
            --ink-secondary: #5c5c5c;
            --border-color: #b0a69a;
            --blood-red: #8a0303;
            --faded-blue: #4a6b8a;
            --tarnished-gold: #c8a415;
            --faded-green: #556b2f;
        }

        body { 
            background-image: url('https://www.transparenttextures.com/patterns/dark-wood.png');
            background-color: #3e2723;
            color: var(--paper-bg); 
            font-family: 'Merriweather', serif; 
            overscroll-behavior-y: contain; 
        }

        .font-western { font-family: 'Rye', cursive; }
        .font-pulp-title { font-family: 'Special Elite', monospace; }

        .card { 
            border: 2px solid var(--ink-main);
            color: var(--ink-main);
            border-radius: 4px;
            padding: 8px; 
            margin: 5px; 
            text-align: center; 
            box-shadow: 3px 3px 8px rgba(0,0,0,0.2); 
            cursor: pointer; 
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.2s; 
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Adjusted for character cards */
            position: relative; 
            width: 7.5rem; 
            height: 10.5rem; 
            font-size: 0.8rem; 
            flex-shrink: 0;
            background-color: var(--paper-bg); 
        }
        .card:hover { 
            transform: translateY(-4px) rotate(-1deg); 
            box-shadow: 4px 4px 12px rgba(0,0,0,0.25); 
        }
        .card.selected {
            border: 3px solid var(--tarnished-gold);
            box-shadow: 0 0 15px rgba(200, 164, 21, 0.5);
            transform: translateY(-2px);
        }
        
        .tint-red { background-color: rgba(138, 3, 3, 0.07); }
        .tint-green { background-color: rgba(85, 107, 47, 0.08); }
        .tint-blue { background-color: rgba(74, 107, 138, 0.08); }
        .tint-gold { background-color: rgba(200, 164, 21, 0.07); } 
        .tint-grey { background-color: rgba(100, 100, 100, 0.05); }

        .card-content-wrapper { 
            overflow: hidden; 
            margin-top: 2.25rem; 
        }
        
        #characterSelection .card .card-content-wrapper {
             margin-top: 0; 
        }


        .card-name { 
            font-family: 'Special Elite', monospace;
            font-weight: bold; 
            font-size: 0.95em;
            line-height: 1.2;
            text-transform: uppercase;
            color: var(--ink-main);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%; 
        }
        .card-type { 
            font-family: 'Merriweather', serif;
            font-style: italic;
            color: var(--ink-secondary); 
            font-size: 0.75em; 
            margin-top: 2px;
        }

        .card-bottom-text {
            font-family: 'Special Elite', monospace;
            font-weight: bold;
            margin-top: auto; 
        }
        .buy-cost { color: var(--faded-blue); font-size: 0.95em; }
        .threat-health { color: var(--blood-red); font-size: 1em; }

        .player-area { 
            background-color: var(--paper-bg); /* Changed to opaque */
            color: var(--ink-main);
            padding: 20px; 
            border-radius: 2px; 
            margin-bottom: 10px; 
            box-shadow: none; 
            border: 1px solid var(--border-color); 
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s, transform 0.2s;
        }
        
        @keyframes player-damage-flash-initial {
            0%, 100% { 
                transform: translateX(0) rotate(0deg); 
                background-color: var(--paper-bg); /* Opaque base */
                border-color: var(--border-color); 
                box-shadow: none;
            }
            25% { transform: translateX(-12px) rotate(-3deg); }
            50% { 
                transform: translateX(0) rotate(0deg); 
                background-color: #f8e6e6; /* Light opaque red */
                border-color: var(--blood-red); 
                box-shadow: 0 0 10px rgba(138, 3, 3, 0.4);
            }
            75% { transform: translateX(12px) rotate(3deg); }
        }
        .player-initial-damage-flash { animation: player-damage-flash-initial 0.4s ease-out; }

        @keyframes player-heal-flash-initial {
            0%, 100% { 
                background-color: var(--paper-bg); /* Opaque base */
                border-color: var(--border-color);
                box-shadow: none;
            }
            50% { 
                background-color: #e6f4e6; /* Light opaque green */
                border-color: var(--faded-green); 
                box-shadow: 0 0 10px rgba(85, 107, 47, 0.4);
            }
        }
        .player-initial-heal-flash { animation: player-heal-flash-initial 0.4s ease-out; }
        
        @keyframes player-border-heal-pulse {
            0%, 100% { border-color: var(--border-color); box-shadow: none; }
            50% { border-color: var(--faded-green); box-shadow: 0 0 18px 3px rgba(85, 107, 47, 0.7); }
        }
        .player-border-pulsing-heal { animation: player-border-heal-pulse 0.3s ease-in-out; }

        @keyframes player-border-damage-pulse {
            0%, 100% { border-color: var(--border-color); box-shadow: none; }
            50% { border-color: var(--blood-red); box-shadow: 0 0 18px 3px rgba(138, 3, 3, 0.7); }
        }
        .player-border-pulsing-damage { animation: player-border-damage-pulse 0.3s ease-in-out; }


        @keyframes threat-damage-flash {
            0%, 100% { transform: scale(1) rotate(0deg); box-shadow: none; }
            50% { transform: scale(1.15) rotate(4deg); box-shadow: 0 0 25px 8px rgba(138, 3, 3, 0.7); }
        }
        .threat-damaged { animation: threat-damage-flash 0.35s ease-out; }
        
        @keyframes gold-flash {
            0%, 100% { transform: scale(1); color: var(--tarnished-gold); }
            50% { transform: scale(1.2); color: #f59e0b; }
        }
        .gold-gained { animation: gold-flash 0.5s ease-out; display: inline-block; }

        .log-area { 
            max-height: 150px; 
            overflow-y: auto; 
            border: 1px solid var(--border-color); 
            padding: 10px; 
            border-radius: 2px; 
            background-color: #faf8f2; 
            font-family: 'Special Elite', monospace;
            font-size: 0.85rem; 
            line-height: 1.4; 
            color: #4a4a4a;
        }
        
        .button { 
            background-color: var(--ink-main); 
            color: var(--paper-bg); 
            padding: 8px 16px; 
            border-radius: 2px; 
            font-family: 'Special Elite', monospace;
            text-transform: uppercase;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer; 
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        .button:hover:not(:disabled) { background-color: var(--blood-red); color: white; border-bottom-color: var(--paper-bg); }
        .button:disabled { background-color: #b0a69a; color: #e0e0e0; cursor: not-allowed; }


        #gameSetup, #gameArea { display: none; } 
       
        .modal-overlay { 
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            background-color: rgba(0, 0, 0, 0.75); 
            z-index: 1000; 
        }
        .modal-content {
            background-color: var(--paper-bg); 
            padding: 2rem; 
            border-radius: 2px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2); 
            width: 90vw;
            max-width: 800px; 
            text-align: left; 
            border: 2px solid var(--ink-main);
            color: var(--ink-main);
            display: flex; flex-direction: column; gap: 1rem;
        }
        .modal-title { font-family: 'Rye', cursive; font-size: 2rem; color: var(--ink-main); text-align: center; }
        .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }
        .modal-close-button { align-self: center; }


        .card-actions {
            position: absolute; bottom: 8px; left: 50%;
            transform: translateX(-50%);
            width: 100%; display: flex; flex-direction: column;
            align-items: center; gap: 4px;
            opacity: 0; transition: opacity 0.2s;
            pointer-events: none; z-index: 10;
        }
        .card.selected .card-actions { opacity: 1; pointer-events: all; }
        .card.selected .card-content-wrapper { opacity: 0.2; }
       
        #characterSelection .card.selected .card-name { 
          opacity: 1; 
        }
        #characterSelection .card.selected .card-actions {
            opacity: 0; 
            pointer-events: none;
        }

        
        .action-btn {
            padding: 4px; width: 85%;
            font-size: 0.7rem; border-radius: 2px;
            background-color: var(--ink-main); color: var(--paper-bg);
            border: 1px solid var(--paper-bg); cursor: pointer;
            transition: background-color 0.15s, transform 0.15s;
            font-family: 'Special Elite', monospace; text-transform: uppercase;
        }
        .action-btn:hover:not(:disabled) { background-color: var(--blood-red); }
        .action-btn:disabled { background-color: #9e9e9e; cursor: not-allowed; }

        #player1EquippedDisplay {
            padding: 0.5rem;
            background-color: rgba(0,0,0,0.03); border-radius: 2px;
            min-height: 11.5rem; border: 1px dashed var(--border-color);
        }
        .equipped-slot { 
            width: 7.5rem; height: 10.5rem; 
            border: 2px dashed var(--border-color); border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            color: var(--border-color); font-size: 0.8em;
            text-align: center;
        }
        
        #naturalThreatOverlay {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Rye', cursive;
            color: var(--blood-red);
            text-shadow: 2px 2px 0px var(--paper-bg), 4px 4px 0px rgba(0,0,0,0.2);
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s ease-out; 
            z-index: 1002; 
            width: 100%; text-align: center;
            font-size: clamp(4rem, 12vw, 10rem);
        }

        #endGameBanner { 
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Rye', cursive;
            text-shadow: 2px 2px 0px var(--paper-bg), 4px 4px 0px rgba(0,0,0,0.2);
            opacity: 0; pointer-events: none;
            z-index: 1003; 
            width: 100%; text-align: center;
            font-size: clamp(5rem, 15vw, 12rem);
        }


        .card-top-left, .card-top-right {
            font-family: 'Special Elite', monospace;
            font-size: 1.2em; padding: 2px 4px;
            border-radius: 2px; background: rgba(255, 255, 255, 0.6);
        }
        .card-top-left { position: absolute; top: 5px; left: 5px; color: var(--tarnished-gold); border: 1px solid var(--tarnished-gold); }
        .card-top-right { position: absolute; top: 5px; right: 5px; color: var(--blood-red); border: 1px solid var(--blood-red); }
        
        .deck-counter-info {
            font-size: 0.75rem;
            color: var(--ink-main); 
            margin-top: 0.25rem; 
        }

        #laudanumEffectOverlay {
            position: fixed; inset: 0; z-index: 2000;
            background: radial-gradient(ellipse at center, rgba(106, 27, 154, 0.5) 0%, rgba(49, 27, 146, 0.9) 100%);
            opacity: 0; pointer-events: none;
        }
        .laudanum-active {
            animation: laudanum-pulse 2s ease-out; 
        }
        @keyframes laudanum-pulse {
            0% { opacity: 0; transform: scale(0.95) rotate(-1deg); filter: blur(3px); }
            50% { opacity: 1; transform: scale(1.25) rotate(1deg); filter: blur(1px); }
            100% { opacity: 0; transform: scale(1.1) rotate(0deg); filter: blur(2px); }
        }

        .scouted-card-preview-container {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            display: flex; align-items: center; justify-content: center;
            background-color: rgba(0,0,0,0.6);
            z-index: 2000; 
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
        }
        .scouted-card-preview-container.visible {
            opacity: 1;
            pointer-events: all;
        }
        .scouted-card-preview-container .card { 
            transform: scale(1.5);
            box-shadow: 0 0 30px 10px rgba(255, 255, 150, 0.5);
        }

    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body class="p-2 sm:p-4">
    <div id="laudanumEffectOverlay"></div>
    <div id="naturalThreatOverlay"></div>
    <div id="endGameOverlay" class="fixed inset-0 bg-black opacity-0 pointer-events-none z-[1002] transition-opacity"></div>
    <div id="endGameBanner" class="fixed inset-0 flex items-center justify-center pointer-events-none z-[1003] opacity-0 transition-opacity">
        <h1 id="endGameText" class="text-8xl font-western"></h1>
    </div>
    <div id="scoutedCardContainer" class="scouted-card-preview-container">
        <!-- Scouted card will be injected here -->
    </div>

    <div id="app" class="container mx-auto p-4 rounded-lg shadow-xl max-w-7xl" aria-live="polite"> 
        <h1 class="text-4xl font-western text-center text-stone-200 mb-6" style="text-shadow: 2px 2px 4px #000;">Wild West Showdown</h1>

        <div id="gameSetup">
            <h2 class="text-2xl font-western text-center text-stone-200 mb-4">Choose Your Legend</h2>
            <div id="characterSelection" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            </div>
            <div id="characterDescription" class="mt-4 p-3 bg-stone-200/80 rounded shadow-inner min-h-[4rem] text-sm text-stone-800 max-h-48 overflow-y-auto" aria-live="polite">Select a character to see their details.</div>
            <div id="namePrompt" class="text-center mt-4 hidden">
                <input type="text" id="characterNameInput" placeholder="Enter your character's name" aria-label="Character's Name" class="p-2 border border-[#8c6b4f] rounded text-lg text-stone-800">
                <button id="confirmNameButton" class="button text-lg">Confirm Name</button>
            </div>
            <div class="text-center">
                <button id="startGameButton" class="button mt-6 hidden text-lg">Start the Showdown!</button>
            </div>
        </div>

        <div id="gameArea" class="hidden">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6"> 
                <div id="player1Area" class="player-area" aria-live="polite" aria-atomic="true"> 
                    <div class="flex justify-between">
                        <div class="mb-4">
                            <h3 class="text-xl font-western text-stone-800 mb-2">You (<span id="player1Name" class="font-mono text-sm"></span>)</h3>
                            <p>Character: <span id="player1Character" class="font-semibold"></span></p>
                            <p>Health: <span id="player1Health" class="font-bold text-red-700 text-lg"></span></p>
                            <p>Gold: <span id="player1Gold" class="font-bold text-yellow-500 text-lg">0</span></p>
                        </div>
                        <div>
                            <h4 class="font-semibold mb-1 text-right">Deck Info</h4>
                            <p class="text-right">Total Cards: <span id="playerDeckTotalCount" class="font-bold text-blue-600">0</span></p>
                            <p class="text-right">Deck: <span id="playerDeckCount" class="font-bold text-blue-600">0</span></p>
                            <p class="text-right">Discard: <span id="playerDiscardCount" class="font-bold text-blue-400">0</span></p>
                        </div>
                    </div>

                    <h4 class="font-semibold mt-3 mb-1">Equipped Items (<span id="player1EquippedCount"></span>):</h4>
                    <div class="flex items-start gap-2"> 
                        <div id="player1EquippedDisplay" class="flex flex-wrap gap-2 flex-shrink-0" style="width: calc(3 * 7.5rem + 2 * 0.5rem);"></div>
                        <div id="equippedNote" class="text-xs italic p-2 text-stone-600 flex-grow self-start max-w-[12rem]">An equipped iron ain't just for show. It strikes twice as hard.</div>
                    </div>
                    <h4 class="font-semibold mt-3 mb-1">Hand (<span id="player1HandCount"></span>):</h4>
                    <div id="player1HandDisplay" class="flex flex-wrap gap-2 mt-1 min-h-[22rem] bg-black/5 p-2 rounded border border-dashed border-gray-400"> 
                    </div>
                     <div id="cardDescription" class="mt-4 p-3 bg-stone-200/80 rounded shadow-inner min-h-[6rem] text-sm hidden max-h-48 overflow-y-auto" aria-live="polite">Select a card to see its details.</div>
                </div>

                <div class="player-area relative flex flex-col">
                    <div class="flex-grow">
                        <div class="mt-0"> 
                            <div class="flex flex-col items-center mb-2"> 
                                <h4 class="font-western text-lg text-blue-700">General Store:</h4>
                                <div id="storeItemDeckInfo" class="deck-counter-info">Store Deck: <span id="storeItemDeckCount">?</span> cards</div>
                                <button id="restockButton" class="button !mt-1 !py-1 !px-2 text-sm w-full max-w-xs">Restock (1G)</button>
                            </div>
                            <div id="storeDisplay" class="flex flex-wrap gap-2 mt-1 justify-center"> 
                            </div>
                        </div>
                        <hr class="my-4 border-gray-400"> 
                        <h3 class="text-xl font-western text-stone-800 mb-2">The Frontier</h3>
                        <div class="flex justify-between mb-2">
                             <div id="eventDeckInfo" class="deck-counter-info !text-left">Event Deck: <span id="eventDeckCount" class="font-bold text-red-600">0</span></div>
                        </div>
                        <div class="flex justify-start gap-4">
                            <div id="activeEventCard" class="card event-display-card" aria-live="polite">No active event.</div>
                            <div id="eventDescription" class="flex-grow p-3 bg-stone-200/80 rounded shadow-inner text-sm h-[10.5rem] overflow-y-auto max-h-48" aria-live="polite"></div>
                        </div>
                        <div class="flex justify-between items-stretch gap-4 mt-2">
                            <div id="activeTrapDisplay" class="w-full flex items-center justify-center p-2 bg-white rounded shadow text-center font-semibold">Trap: None</div>
                            <div id="turnIndicator" class="w-full flex items-center justify-center p-2 bg-white rounded shadow text-center font-semibold">Day: <span id="turnNumberDisplay">1</span></div>
                            <button id="endTurnButton" class="button w-full !mt-0">End Day</button>
                        </div>
                    </div>
                    
                    <div id="playerActions" class="mt-auto"> 
                         <div class="my-4">
                            <h3 class="text-xl font-western text-center text-stone-800 mb-2">Town Crier (Log)</h3>
                            <div id="gameLog" class="log-area bg-white p-3 rounded shadow" aria-live="polite" aria-atomic="false">
                            </div>
                         </div>
                         <button id="restartButton" class="button w-full bg-red-800 hover:bg-red-900 border-red-900">Restart Game</button>
                    </div>
                </div>
            </div>
        </div>
       
        <div id="messageModal" class="modal-overlay hidden">
            <div class="modal-content">
                <h3 id="messageModalTitle" class="modal-title">Howdy Partner!</h3>
                <p id="messageModalText" class="modal-body"></p>
                <button id="messageModalCloseButton" class="button modal-close-button">Alright</button>
            </div>
        </div>
        <div id="storyModal" class="modal-overlay hidden">
            <div class="modal-content">
                <h3 id="storyModalTitle" class="modal-title">Your Legend</h3>
                <p id="storyModalText" class="modal-body whitespace-pre-wrap">Writing your legend...</p>
                <button id="storyModalCloseButton" class="button modal-close-button">Farewell</button>
            </div>
        </div>
    </div>
    <script>
        // --- Game Config and Global Vars ---
        const GEMINI_API_KEY = "AIzaSyCa7ymQSXzZuJbNbXB-xTVGZ0UqmFeCESo"; 
        let localGameState = null;
        let isEndingTurn = false;
        const playerId = 'player';
        const MAX_LOG_ENTRIES = 50; 
        const HAND_LIMIT = 6; 
        const EQUIP_LIMIT = 3;
        const STORE_DISPLAY_LIMIT = 3;
        const EVENT_DECK_SIZE = 20; 
        const MAX_NON_THREAT_EVENTS = 4; 

        let ui = {}; 

        const CHARACTERS_DATA = {
            hunter: { 
                id: 'hunter', name: 'Hunter', health: 20, gold: 20,
                ability: 'A master of the wild, their aim is as true as the northern star.', 
                starterDeck: ['item_bow', 'upgrade_bearskin_coat', 'provision_large_meat', 'upgrade_lucky_arrowhead'],
                storyDesc: "Clad in a patchwork of deer hides and worn leather, their clothes are a testament to a life lived on the fringes. A hawk feather is tucked into the band of their faded hat, and their eyes miss nothing."
            },
            trapper: { 
                id: 'trapper', name: 'Trapper', health: 18, gold: 25,
                ability: 'Knows every trail and snare; a survivor who lives off the land.', 
                starterDeck: ['item_knife', 'upgrade_bearskin_coat', 'provision_small_meat', 'upgrade_worn_whetstone'],
                storyDesc: "They smell of pine, smoke, and something animal. Their buckskin clothes are stained from their trade, and their hands are thick and calloused, constantly fidgeting with the handle of a well-used skinning knife."
            },
            gunslinger: { 
                id: 'gunslinger', name: 'Gunslinger', health: 24, gold: 20,
                ability: 'Their reputation is written in smoke, their legend told in thunder.', 
                starterDeck: ['item_six_shooter', 'upgrade_bandolier', 'provision_laudanum', 'upgrade_lucky_bullet'],
                storyDesc: "A long, dark duster coat hangs on their frame, its hem caked with the dust of a dozen towns. Their gaze is steady, and their hand hovers instinctively near the worn leather grip of their holstered pistol."
            },
            doctor: { 
                id: 'doctor', name: 'Doctor', health: 18, gold: 25,
                ability: 'A steady hand that can mend flesh or end a life with grim precision.', 
                starterDeck: ['item_knife', 'upgrade_duster', 'provision_miracle_cure', 'upgrade_medical_journal'],
                storyDesc: "Even in the wild, they maintain an air of professionalism, with a clean (if wrinkled) shirt and spectacles perched on their nose. Their leather bag smells sharply of carbolic acid and strange poultices."
            },
            herbalist: { 
                id: 'herbalist', name: 'Herbalist', health: 18, gold: 20,
                ability: 'Finds life and remedy where others only see weeds and dirt.', 
                starterDeck: ['item_knife', 'upgrade_satchel', 'provision_juniper', 'upgrade_herb_pouch'],
                storyDesc: "Their clothes are practical homespun linen, often stained with berry juice and dirt. Twigs and dried flowers are woven into their hair, and their soft deerskin pouch is always close at hand."
            },
            explorer: { 
                id: 'explorer', name: 'Explorer', health: 18, gold: 28,
                ability: 'Driven by wanderlust and the promise of what lies over the next hill.', 
                starterDeck: ['item_six_shooter', 'upgrade_boots', 'provision_water', 'upgrade_treasure_map'],
                storyDesc: "Their sun-faded canvas shirt is worn thin, and their boots are caked with mud from countless miles. Their eyes, always scanning the horizon, hold the glint of endless optimism and far-off lands."
            },
            preacher: {
                id: 'preacher', name: 'Preacher', health: 22, gold: 25,
                ability: 'Wields scripture and judgment with equal, unwavering conviction.',
                starterDeck: ['item_knife', 'upgrade_iron_will', 'provision_laudanum', 'upgrade_tattered_bible'],
                storyDesc: "A gaunt figure in a dusty, threadbare black coat. Their face is all sharp angles and hollow cheeks, and their eyes burn with a feverish intensity as they clutch a worn, leather-bound book to their chest."
            },
            prospector: {
                id: 'prospector', name: 'Prospector', health: 16, gold: 30,
                ability: 'Haunted by the glimmer of gold and the ghosts of the mountains.',
                starterDeck: ['item_sawed_off', 'upgrade_satchel', 'provision_water', 'item_gold_pan'],
                storyDesc: "Their clothes are more patch than fabric, and their wild, grey beard is stained with tobacco. There's a constant film of grime under their fingernails, and their sunken eyes glitter with a desperate hope."
            }
        };
        const CHARACTERS_LIST = Object.values(CHARACTERS_DATA); 
       
        const ALL_CARDS_DATA = {
            // Animal Threats
            'threat_skunk': { name: 'Skunk', type: 'Event', subType: 'animal', health: 2, goldValue: 2, effect: {type: 'damage', amount: 1}, description: "A startled skunk. It's more scared of you than you are of it, but it might still spray." },
            'threat_beaver': { name: 'Beaver', type: 'Event', subType: 'animal', health: 4, goldValue: 2, effect: {type: 'conditional_damage', condition:'item_wood', damage: 0}, description: "A large beaver, fiercely protective of its dam. It seems to have an affinity for wood." },
            'threat_coyote': { name: 'Coyote', type: 'Event', subType: 'animal', health: 4, goldValue: 2, effect: {type: 'conditional_damage', condition:'provision', damage: 4}, description: "A cunning coyote, eyeing your food supplies." },
            'threat_fox': { name: 'Fox', type: 'Event', subType: 'animal', health: 4, goldValue: 4, effect: {type: 'conditional_damage', condition:'item', damage: 4}, description: "A sly fox, more interested in your trinkets than a fight." },
            'threat_wolf': { name: 'Wolf', type: 'Event', subType: 'animal', health: 6, goldValue: 4, effect: {type:'damage', amount: 4}, description: "A lone wolf, lean and hungry, sizing you up from a distance." },
            'threat_boar': { name: 'Boar', type: 'Event', subType: 'animal', health: 6, goldValue: 6, effect: {type:'damage', amount: 4}, description: "A wild boar, with sharp tusks and a mean temper." },
            'threat_buck': { name: 'Buck', type: 'Event', subType: 'animal', health: 8, goldValue: 6, effect: {type:'damage', amount: 8}, description: "A magnificent buck, with antlers like daggers and a powerful charge." },
            'threat_bear': { name: 'Bear', type: 'Event', subType: 'animal', health: 10, goldValue: 10, effect: {type:'damage', amount: 8}, description: "A large bear, standing on its hind legs to get a better look at you." },
            'threat_black_bear': { name: 'Black Bear', type: 'Event', subType: 'animal', health: 12, goldValue: 16, effect: {type:'damage', amount: 12}, description: "A massive black bear, its fur matted with blood and dirt." },
            'threat_wolf_pack': { name: 'Wolf Pack', type: 'Event', subType: 'animal', health: 14, goldValue: 20, effect: {type:'damage', amount: 12}, description: "A pack of wolves, circling you with hungry eyes." },
            'threat_grizzly_bear': { name: 'Grizzly Bear', type: 'Event', subType: 'animal', health: 16, goldValue: 30, effect: {type:'damage', amount: 12}, description: "An enormous grizzly, its roar echoing through the valley." },
            'threat_rabbit': { name: 'Rabbit', type: 'Event', subType: 'animal', health: 1, goldValue: 1, effect: {type:'damage', amount: 0}, description: "A harmless rabbit, twitching its nose at you." },
            'threat_squirrel': { name: 'Squirrel', type: 'Event', subType: 'animal', health: 1, goldValue: 1, effect: {type:'damage', amount: 0}, description: "A chattering squirrel, more a nuisance than a threat." },

            // Generic Threats
            'threat_thief': { name: 'Thief', type: 'Event', subType: 'human', health: 6, goldValue: 10, effect: {type: 'lose_gold', amount: 5}, description: "A shifty-eyed thief, looking to lighten your coin purse before disappearing into the wilderness." },
            'threat_outlaw': { name: 'Outlaw', type: 'Event', subType: 'human', health: 8, goldValue: 16, effect: {type:'damage', amount: 8}, description: "A hardened outlaw, with a bounty on his head and a pistol in his hand, ready to defend his ill-gotten gains." },
            'threat_bandit': { name: 'Bandit', type: 'Event', subType: 'human', health: 10, goldValue: 20, effect: {type:'damage', amount: 8}, description: "A ruthless bandit, leading a small gang of rogues. They're known for leaving no witnesses." },
            'threat_malaria': { name: 'Malaria', type: 'Event', subType: 'illness', effect: {type: 'damage', amount: 2, turn_end: true}, description: "You feel a sudden chill, and your bones begin to ache. A fever is setting in, a grim souvenir from the wild." },
            'threat_snake_bite': { name: 'Snake Bite', type: 'Event', subType: 'illness', effect: {type: 'poison', damage: 2, turn_end: true}, description: "A sharp pain in your leg reveals two small puncture wounds. A rattlesnake slithers away into the underbrush, its venom already at work." },
            'threat_lightning_strike': { name: 'Lightning Strike', type: 'Event', subType: 'environmental', effect: {type: 'damage_percent', amount: 0.5, turn_end: true}, description: "A sudden storm rolls in, and a bolt of lightning strikes terrifyingly close, the air crackling with energy." },
            'threat_rockslide': { name: 'Rockslide', type: 'Event', subType: 'environmental', effect: {type: 'damage', amount: 2, turn_end: true, discard_equipped: true}, description: "The ground trembles as rocks and debris tumble down the mountainside, threatening to bury you alive." },
            'threat_dysentery': { name: 'Dysentery', type: 'Event', subType: 'illness', effect: {type: 'poison', damage: 2, turn_end: true}, description: "A wave of nausea and stomach cramps signals a debilitating illness, likely from a contaminated water source." },

            // Provisions
            'provision_juniper': { name: 'Juniper', type: 'Provision', sellValue: 2, buyCost: 4, effect: {type:'heal', amount: 1, cures: true}, description: "The berries of this hardy shrub are known to purify the blood and mend minor ailments." },
            'provision_basil': { name: 'Basil', type: 'Provision', sellValue: 2, buyCost: 4, effect: {type:'heal', amount: 1, cures: true}, description: "A fragrant herb, often used in poultices to draw out infection and aid in recovery." },
            'provision_laudanum': { name: 'Laudanum', type: 'Provision', sellValue: 6, buyCost: 12, effect: {type:'heal', amount: 4}, description: "An opioid tincture that is highly effective at dulling even the most severe pain, though its use is not without risk." },
            'provision_stamina_tonic': { name: 'Stamina Tonic', type: 'Provision', sellValue: 8, buyCost: 16, effect: {type:'draw', amount: 2}, description: "A bitter concoction that quickens the senses and puts a spring back in your step." },
            'provision_fever_tonic': { name: 'Fever Tonic', type: 'Provision', sellValue: 5, buyCost: 10, effect: {type:'heal', amount: 2, cures: true}, description: "A herbal remedy passed down through generations, known to break fevers and fight off sickness." },
            'provision_health_tonic': { name: 'Health Tonic', type: 'Provision', sellValue: 8, buyCost: 16, effect: {type:'heal', amount: 4}, description: "A restorative draught that replenishes vitality and helps to knit wounds." },
            'provision_miracle_cure': { name: 'Miracle Cure', type: 'Provision', sellValue: 15, buyCost: 30, effect: {type:'heal', amount: 8, cures: true}, description: "A patent medicine sold by a traveling salesman. Its contents are a mystery, but its restorative effects are undeniable." },
            'provision_small_meat': { name: 'Small Meat', type: 'Provision', sellValue: 1, buyCost: 2, effect: {type:'heal', amount: 1}, description: "The meager but welcome meat from a small catch, enough to stave off hunger for a short while." },
            'provision_medium_meat': { name: 'Medium Meat', type: 'Provision', sellValue: 2, buyCost: 4, effect: {type:'heal', amount: 2}, description: "A respectable portion of meat, enough to fuel a day's hard journey." },
            'provision_large_meat': { name: 'Large Meat', type: 'Provision', sellValue: 3, buyCost: 6, effect: {type:'heal', amount: 3}, description: "A substantial haul of fresh meat, promising a full belly and renewed strength." },
            'provision_water': { name: 'Water', type: 'Provision', sellValue: 1, buyCost: 2, effect: {type:'heal', amount: 3}, description: "Clean, clear water; the most essential provision for survival in the harsh wilderness." },

            // Items & Actions
            'item_sawed_off': { name: 'Sawed Off', type: 'Item', sellValue: 15, buyCost: 30, effect: {type: 'weapon', attack: 3}, description: "A shotgun with its barrel cut short. What it lacks in range, it makes up for in raw, devastating power at close quarters." },
            'item_rifle': { name: 'Rifle', type: 'Item', sellValue: 20, buyCost: 40, effect: {type: 'weapon', attack: 4}, description: "A reliable long gun, accurate and deadly from a distance. The weapon of a patient hunter." },
            'item_six_shooter': { name: 'Six Shooter', type: 'Item', sellValue: 15, buyCost: 30, effect: {type: 'weapon', attack: 3}, description: "The iconic revolver of the West. A reliable and quick-drawing sidearm for any confrontation." },
            'item_bow': { name: 'Bow', type: 'Item', sellValue: 10, buyCost: 20, effect: {type: 'weapon', attack: 2}, description: "A simple yet effective weapon. Its silent arrows are perfect for hunting or a stealthy ambush." },
            'item_knife': { name: 'Knife', type: 'Item', sellValue: 5, buyCost: 10, effect: {type: 'weapon', attack: 1}, description: "More than just a tool for whittling and skinning; in a pinch, it's a deadly weapon for close-in fights." },
            'item_small_trap': { name: 'Small Trap', type: 'Item', sellValue: 6, buyCost: 12, effect: {type:'trap', size:'small'}, description: "A simple snare, perfect for catching rabbits, squirrels, and other small game for the pot." },
            'item_large_trap': { name: 'Large Trap', type: 'Item', sellValue: 15, buyCost: 30, effect: {type:'trap', size:'large'}, description: "A heavy, spring-loaded trap with iron jaws, capable of bringing down deer, or stopping a predator in its tracks." },
            'item_gold_nugget': { name: 'Gold Nugget', type: 'Item', sellValue: 25, description: "A solid piece of raw gold, a rare and thrilling find for any prospector. Can be sold for a hefty sum." }, // Effect removed
            'item_jewelry': { name: 'Jewelry', type: 'Item', sellValue: 15, description: "A piece of once-fine jewelry, perhaps a locket or ring, that will fetch a pretty penny in the right town. Can be sold." }, // Effect removed
            'item_wood': { name: 'Firewood', type: 'Item', sellValue: 2, buyCost: 4, effect: {type:'campfire'}, description: "A bundle of dry firewood, essential for keeping the chill of the night at bay and cooking a warm meal." },
            'item_fire_arrows': { name: 'Fire Arrows', type: 'Item', sellValue: 10, buyCost: 20, effect: { type: 'fire_arrow' }, description: "Arrows with oil-soaked rags tied to the tips. When lit, they can set fire to nearly anything they strike." },
            'item_gold_pan': { name: 'Gold Pan', type: 'Item', sellValue: 10, buyCost: 15, effect: { type: 'gold', amount: 1}, description: "A simple pan. Swirl some dirt and water, and you might find a fleck of gold. Play to gain 1 Gold." },
            'action_scout_ahead': { name: 'Scout Ahead', type: 'Action', sellValue: 10, buyCost: 20, effect: { type: 'scout' }, description: "Take a moment to survey the path ahead, revealing the next encounter before you commit." },
            'action_trick_shot': { name: 'Trick Shot', type: 'Action', sellValue: 12, buyCost: 24, effect: { type: 'conditional_weapon', attack: 3, bonus_attack: 3, condition: 'is_firearm' }, description: "A risky but potent shot. Deals 3 damage. If you have another firearm in your hand, it deals 6 damage instead." },
            
            // Player Upgrades
            'upgrade_lucky_arrowhead': { name: 'Lucky Arrowhead', type: 'Player Upgrade', sellValue: 5, effect: { type: 'upgrade', subtype: 'bow_boost', amount: 1, persistent: true }, description: "A uniquely shaped arrowhead you found. It seems to guide your arrows with uncanny accuracy, adding +1 to Bow attacks." },
            'upgrade_worn_whetstone': { name: 'Worn Whetstone', type: 'Player Upgrade', sellValue: 5, effect: { type: 'upgrade', subtype: 'knife_boost', amount: 1, persistent: true }, description: "A smooth, pocket-worn stone that puts a razor's edge on any blade, adding +1 to Knife attacks." },
            'upgrade_lucky_bullet': { name: 'Lucky Bullet', type: 'Player Upgrade', sellValue: 5, effect: { type: 'upgrade', subtype: 'firearm_boost', amount: 1, persistent: true }, description: "A single, strangely marked cartridge. Keeping it on your person seems to steady your aim, adding +1 to Firearm attacks." },
            'upgrade_medical_journal': { name: 'Medical Journal', type: 'Player Upgrade', sellValue: 5, effect: { type: 'upgrade', subtype: 'provision_heal_boost', amount: 1, persistent: true }, description: "A well-read journal filled with anatomical sketches and notes on herbal remedies. When equipped, all healing provisions are boosted by +1." },
            'upgrade_herb_pouch': { name: 'Herb Pouch', type: 'Player Upgrade', sellValue: 5, effect: { type: 'upgrade', subtype: 'herb_boost', amount: 2, persistent: true }, description: "A small leather pouch that helps preserve the freshness and potency of medicinal herbs. Adds +2 to all herbs." },
            'upgrade_treasure_map': { name: 'Treasure Map', type: 'Player Upgrade', sellValue: 5, effect: { type: 'upgrade', subtype: 'sell_boost', amount: 2, persistent: true }, description: "A cryptic map, either real or a clever fake, that seems to grant you an eye for a good deal. Adds +2 gold to all sold cards." },
            'upgrade_tattered_bible': { name: 'Tattered Bible', type: 'Player Upgrade', sellValue: 5, effect: { type: 'upgrade', subtype: 'damage_reduction', amount: 1, persistent: true }, description: "A small, worn Bible that has seen better days. Its presence offers some small comfort, reducing all incoming damage by 1." },
            'upgrade_satchel': { name: 'Satchel', type: 'Player Upgrade', sellValue: 15, buyCost: 30, effect: {type:'upgrade', subtype:'storage', capacity: 3, persistent: true}, description: "A sturdy leather satchel that allows you to carry more provisions and supplies on your journey." },
            'upgrade_bandolier': { name: 'Bandolier', type: 'Player Upgrade', sellValue: 15, buyCost: 30, effect: {type:'upgrade', subtype:'double_fire', persistent: true}, description: "A leather belt worn over the shoulder, loaded with ammunition. It allows you to fire twice in quick succession." },
            'upgrade_duster': { name: 'Duster', type: 'Player Upgrade', sellValue: 25, buyCost: 50, effect: {type:'upgrade', subtype:'max_health', amount: 5, persistent: true}, description: "A long, heavy coat that protects from the trail's dust and grime, while also offering a bit of protection from harm." },
            'upgrade_boots': { name: 'Boots', type: 'Player Upgrade', sellValue: 25, buyCost: 50, effect: {type:'upgrade', subtype:'max_health', amount: 5, persistent: true}, description: "A pair of sturdy, well-made boots, essential for covering the long and arduous miles ahead." },
            'upgrade_bearskin_coat': { name: 'Bearskin Coat', type: 'Player Upgrade', sellValue: 30, buyCost: 60, effect: {type:'upgrade', subtype:'max_health', amount: 7, persistent: true}, description: "A thick and heavy coat made from the hide of a great bear. It provides exceptional warmth and protection." },
            'upgrade_iron_will': { name: 'Iron Will', type: 'Player Upgrade', sellValue: 40, buyCost: 80, effect: {type:'upgrade', subtype:'max_health', amount: 10, persistent: true}, description: "Through hardship, you have developed an unyielding resolve and a stronger constitution." },
            'upgrade_hat': { name: 'Hat', type: 'Player Upgrade', sellValue: 10, buyCost: 20, effect: {type:'upgrade', subtype:'damage_negation', max_health: 2, persistent: true}, description: "A simple but effective hat, offering a modicum of protection from the sun and, occasionally, a lucky break from harm." },
            'upgrade_racoon_skin_hat': { name: 'Racoon Skin Hat', type: 'Player Upgrade', sellValue: 12, buyCost: 24, effect: {type:'upgrade', subtype:'damage_negation', max_health: 2, persistent: true}, description: "A rustic but practical hat, a sign of a true frontiersman who knows how to make do with what the land provides." },
            'upgrade_fine_felt_hat': { name: 'Fine Felt Hat', type: 'Player Upgrade', sellValue: 15, buyCost: 30, effect: {type:'upgrade', subtype:'damage_negation', max_health: 2, persistent: true}, description: "A stylish hat that speaks of a more refined past, yet it proves just as capable of turning aside a glancing blow." }
        };
       
        function showModal(title, text, confirmCallback = null) {
            if (ui.messageModal && ui.messageModal.title && ui.messageModal.text && ui.messageModal.overlay) {
                ui.messageModal.title.textContent = title;
                ui.messageModal.text.textContent = text;
                ui.messageModal.overlay.classList.remove('hidden');
                
                const existingConfirmBtn = ui.messageModal.overlay.querySelector('.confirm-action-button');
                if(existingConfirmBtn) existingConfirmBtn.remove(); 

                if (confirmCallback) {
                    const confirmBtn = document.createElement('button');
                    confirmBtn.textContent = "Confirm";
                    confirmBtn.className = "button mt-2 confirm-action-button";
                    
                    confirmBtn.onclick = () => {
                        confirmCallback();
                        ui.messageModal.overlay.classList.add('hidden');
                    };
                    ui.messageModal.closeButton.insertAdjacentElement('beforebegin', confirmBtn);
                }

            } else {
                console.error("Modal UI elements not fully initialized for showModal.");
            }
        }
       
        function _log(message, type = 'info') {
            if (!localGameState || !localGameState.log) return;
            const logEntry = { message, type, timestamp: new Date().toISOString() };
            localGameState.log.unshift(logEntry);
            if(localGameState.log.length > MAX_LOG_ENTRIES) localGameState.log.pop();
        }

        function renderGameLog() {
            const logContainer = ui.gameLog;
            if (!logContainer || !localGameState || !localGameState.log) return;
            logContainer.innerHTML = ''; 
            
            const logsToDisplay = localGameState.log.slice(0, MAX_LOG_ENTRIES); 
           
            logsToDisplay.forEach(entry => {
                const p = document.createElement('p');
                const time = new Date(entry.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

                p.textContent = `[${time}] ${entry.message}`;
                if (entry.type === 'error') p.className = 'text-red-600 font-semibold';
                if (entry.type === 'action') p.className = 'text-blue-600';
                if (entry.type === 'system') p.className = 'text-green-700 font-semibold';
                if (entry.type === 'turn') p.className = 'text-purple-700 font-bold underline';
                if (entry.type === 'event') p.className = 'text-red-700 font-semibold'; 
                if (entry.type === 'gold') p.className = 'text-yellow-600 font-semibold';
                if (entry.type === 'debug') p.className = 'text-gray-400 italic text-xs';
                logContainer.appendChild(p);
            });
             logContainer.scrollTop = 0; 
        }
        
        const delay = ms => new Promise(res => setTimeout(res, ms));

        async function triggerCustomFlash(targetElement, animationClass, duration) {
            if (!targetElement) return;
            targetElement.classList.add(animationClass);
            await delay(duration);
            targetElement.classList.remove(animationClass);
        }
        
        async function triggerPulsingBorder(targetElement, pulseClass, count, pulseDuration, interval) {
            if (!targetElement) return;
            for (let i = 0; i < count; i++) {
                targetElement.classList.add(pulseClass);
                await delay(pulseDuration);
                targetElement.classList.remove(pulseClass);
                if (i < count - 1) {
                    await delay(interval - pulseDuration);
                }
            }
        }

        async function triggerHealFlash(healAmount) {
            if (healAmount <= 0 || !ui.p1.area) return;
            await triggerCustomFlash(ui.p1.area, 'player-initial-heal-flash', 400);
            if (healAmount > 0) {
                 await triggerPulsingBorder(ui.p1.area, 'player-border-pulsing-heal', healAmount, 300, 350);
            }
        }
        
        async function triggerDamageFlash(damageAmount) {
            if (damageAmount <= 0) return;
            if (ui.p1.area) {
                await triggerCustomFlash(ui.p1.area, 'player-initial-damage-flash', 400);
            }
            if (ui.p1.area && damageAmount > 0) {
                await triggerPulsingBorder(ui.p1.area, 'player-border-pulsing-damage', damageAmount, 300, 350);
            }
        }
        
        function triggerGoldFlash() {
            const goldDisplay = ui.p1.gold;
            if (!goldDisplay) return;
            goldDisplay.classList.add('gold-gained');
            setTimeout(() => {
                goldDisplay.classList.remove('gold-gained');
            }, 500);
        }

        async function triggerThreatDamageFlash(damage = 1){
            const el = document.getElementById('activeEventCard');
            if (!el) return;
            await triggerCustomFlash(el, 'threat-damaged', 350);
        }

        function triggerNaturalThreatText(eventName) {
            const overlay = document.getElementById('naturalThreatOverlay');
            if (!overlay) return;
            overlay.textContent = eventName.toUpperCase();
            overlay.style.opacity = '1';
            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 1500);
        }
        
        function getCardValues(card, source = 'hand') {
            let damage = 0;
            let goldDisplayValue = null; 
        
            if (card.effect?.type === 'weapon' || card.effect?.type === 'conditional_weapon') {
                damage = card.effect.attack;
                if (source === 'equipped') {
                    damage *= 2;
                }
            }
        
            if (source === 'store') {
                if (card.buyCost) goldDisplayValue = `${card.buyCost}G`;
            } else if (card.type === 'Trophy' || card.type === 'Bounty Proof' || card.id === 'item_gold_nugget' || card.id === 'item_jewelry') {
                if (card.sellValue) goldDisplayValue = `${card.sellValue}G`;
            } else if (card.effect?.type === 'gold' && source !== 'store' && card.id !== 'item_gold_nugget' && card.id !== 'item_jewelry') { 
                 if (card.effect.amount) goldDisplayValue = `${card.effect.amount}G`;
            } else if (card.sellValue > 0 && source === 'hand' && card.id !== 'item_gold_nugget' && card.id !== 'item_jewelry') {
                goldDisplayValue = `${card.sellValue}G`;
            }
        
            return {
                damage: damage > 0 ? `${damage} AT` : null,
                gold: goldDisplayValue
            };
        }
        
        function calculateAttackPower(card, playerDetails, source) {
            let attackPower = card.effect.attack;

            if (card.effect.type === 'conditional_weapon') {
                if (card.effect.condition === 'is_firearm') {
                    const otherFirearms = playerDetails.hand.filter(c => c.id !== card.id && ['item_sawed_off', 'item_rifle', 'item_six_shooter'].includes(c.id));
                    if (otherFirearms.length > 0) {
                        attackPower += card.effect.bonus_attack;
                        _log(`${card.name}'s bonus condition met!`, 'system');
                    }
                }
            }
            
            if (source === 'equipped') { 
                attackPower *= 2;
            }
            if (playerDetails.character.id === 'gunslinger' && playerDetails.equippedItems.some(i => i.id === 'upgrade_lucky_bullet') && ['item_sawed_off', 'item_rifle', 'item_six_shooter'].includes(card.id)) {
                attackPower += 1;
                _log("Lucky Bullet adds +1 damage!", 'system');
            }
            if (playerDetails.character.id === 'hunter' && playerDetails.equippedItems.some(i => i.id === 'upgrade_lucky_arrowhead') && card.id === 'item_bow') {
                attackPower += 1;
                _log("Lucky Arrowhead adds +1 damage!", 'system');
            }
            if (playerDetails.character.id === 'trapper' && playerDetails.equippedItems.some(i => i.id === 'upgrade_worn_whetstone') && card.id === 'item_knife') {
                attackPower += 1;
                _log("Worn Whetstone adds +1 damage!", 'system');
            }
            return attackPower;
        }

        function calculateHealAmount(card, playerDetails) {
            let healAmount = card.effect.amount;
            if(card.id === 'provision_laudanum'){
                const overlay = document.getElementById('laudanumEffectOverlay');
                if(overlay) {
                    overlay.classList.add('laudanum-active');
                    setTimeout(() => overlay.classList.remove('laudanum-active'), 2000); 
                }
            }
            if (playerDetails.character.id === 'doctor' && playerDetails.equippedItems.some(i => i.id === 'upgrade_medical_journal')) {
                healAmount += 1;
                _log("Medical Journal enhances healing by 1.", 'system');
            }
            if (playerDetails.character.id === 'herbalist' && playerDetails.equippedItems.some(i => i.id === 'upgrade_herb_pouch') && (card.id === 'provision_juniper' || card.id === 'provision_basil')) {
                healAmount += 2;
                _log("Herb Pouch enhances herbal healing by 2.", 'system');
            }
            return healAmount;
        }

        async function createInitialGameState(savedDeckData = null) {
            const ngPlusLevel = parseInt(localStorage.getItem('ngPlusLevel') || '0');
            if (ngPlusLevel >= 10) { 
                 await remixCardsForNGPlus();
            }

            const allCards = Object.keys(ALL_CARDS_DATA).map(key => ({...ALL_CARDS_DATA[key], id: key }));
            const characterUpgrades = ['upgrade_lucky_arrowhead', 'upgrade_worn_whetstone', 'upgrade_lucky_bullet', 'upgrade_medical_journal', 'upgrade_herb_pouch', 'upgrade_treasure_map', 'upgrade_tattered_bible', 'item_gold_pan'];
            let playerFacingPool = allCards.filter(card => 
                card.type !== 'Event' && !characterUpgrades.includes(card.id)
            );
            
            const weapons = allCards.filter(c => c.effect?.type === 'weapon');
            playerFacingPool.push(...weapons, ...weapons); 
            playerFacingPool = [...new Set(playerFacingPool.map(c => c.id))].map(id => playerFacingPool.find(c => c.id === id));


            let playerDeck;
            
            if (savedDeckData) { 
                const combinedOldCards = [...savedDeckData.deck, ...savedDeckData.discard, ...savedDeckData.hand, ...savedDeckData.equipped];
                playerDeck = combinedOldCards.map(cardId => ({...ALL_CARDS_DATA[cardId], id: cardId})); 

                let availableCards = playerFacingPool.filter(poolCard => !playerDeck.some(deckCard => deckCard.id === poolCard.id));
                const neededCards = 18 - playerDeck.length; 
                
                if (neededCards > 0) {
                   const newCards = shuffleArray(availableCards).slice(0, neededCards);
                   playerDeck.push(...newCards);
                }
                shuffleArray(playerDeck);
            } else { 
                 const shuffledPlayerPool = shuffleArray(playerFacingPool);
                 playerDeck = shuffledPlayerPool.splice(0, 18); 
            }
            
            let threatCards = allCards.filter(card => card.type === 'Event');
            let nonThreatPoolForEvents = allCards.filter(c => c.type !== 'Event' && (c.type === 'Item' || c.type === 'Provision' || c.type === 'Action'));
            let otherCardsForEventDeck = shuffleArray(nonThreatPoolForEvents).slice(0, MAX_NON_THREAT_EVENTS);
            
            let storeItemDeck = allCards.filter(card => card.buyCost).map(c => ({...c})); 
            shuffleArray(storeItemDeck);
            storeItemDeck = storeItemDeck.slice(0, Math.min(storeItemDeck.length, 20)); 

            let finalEventDeck;

            if(ngPlusLevel === 0) { 
                const sortedThreats = threatCards
                    .filter(c => c.subType === 'animal' || c.subType === 'human') 
                    .sort((a,b) => (a.effect?.amount || a.effect?.damage || 0) - (b.effect?.amount || b.effect?.damage || 0));
                
                const otherEventTypes = shuffleArray(threatCards.filter(c => c.subType === 'environmental' || c.subType === 'illness' || !c.subType));
                
                finalEventDeck = [];
                let mainThreatIdx = 0;
                let otherEventIdx = 0;
                let nonThreatItemIdx = 0;

                while(finalEventDeck.length < EVENT_DECK_SIZE && (mainThreatIdx < sortedThreats.length || otherEventIdx < otherEventTypes.length || nonThreatItemIdx < otherCardsForEventDeck.length)) {
                    if (mainThreatIdx < sortedThreats.length) finalEventDeck.push(sortedThreats[mainThreatIdx++]);
                    if (finalEventDeck.length >= EVENT_DECK_SIZE) break;

                    if (nonThreatItemIdx < otherCardsForEventDeck.length && finalEventDeck.length % 4 === 1) { 
                         finalEventDeck.push(otherCardsForEventDeck[nonThreatItemIdx++]);
                         if (finalEventDeck.length >= EVENT_DECK_SIZE) break;
                    }
                    if (otherEventIdx < otherEventTypes.length) {
                        finalEventDeck.push(otherEventTypes[otherEventIdx++]);
                        if (finalEventDeck.length >= EVENT_DECK_SIZE) break;
                    }
                }
                finalEventDeck.reverse(); 
                
            } else { 
                finalEventDeck = shuffleArray([...threatCards, ...otherCardsForEventDeck]); 
            }

            finalEventDeck = finalEventDeck.slice(0, EVENT_DECK_SIZE); 

            const aiBoss = await generateAIBoss(); 
            if (aiBoss) {
                finalEventDeck.unshift(aiBoss); 
            }
           
            let playerDetails = {
                [playerId]: {
                    name: null,
                    character: null, health: 0, gold: 10, hand: [], 
                    equippedItems: [], activeTrap: null, isCampfireActive: false,
                    maxHealth: 0, handSize: HAND_LIMIT, equipSlots: EQUIP_LIMIT,
                    playerDeck: playerDeck, 
                    playerDiscard: [], hasEquippedThisTurn: false,
                    satchel: [], turnEnded: false,
                    hasTakenActionThisTurn: false, 
                    hasRestockedThisTurn: false,
                    isUnsortedDraw: false, 
                    wasDamagedOrNegativelyAffectedThisTurn: false, // Added
                }
            };

            const initialStoreItems = [];
            for(let i=0; i < STORE_DISPLAY_LIMIT; i++) {
                if (storeItemDeck.length > 0) {
                    initialStoreItems.push(storeItemDeck.pop());
                } else {
                    initialStoreItems.push(null); 
                }
            }

            return {
                status: 'setup', 
                playerDetails: playerDetails,
                eventDeck: finalEventDeck,
                eventDiscardPile: [],
                activeEvent: null,
                storeItemDeck: storeItemDeck, 
                storeDisplayItems: initialStoreItems, 
                turn: 1,
                storyGenerated: false,
                log: [],
                ngPlusLevel: ngPlusLevel, 
            };
        }
       
        function renderCharacterSelection() {
            if (!ui.characterSelection) return;
            ui.characterSelection.innerHTML = '';
            ui.startGameButton.classList.add('hidden');
            ui.characterDescription.innerHTML = 'Select a character to see their details.';
            
            const ngPlusLevel = parseInt(localStorage.getItem('ngPlusLevel') || '0');
            const existingNgPlusDisplay = document.getElementById('ngPlusDisplay');
            if (existingNgPlusDisplay) {
                existingNgPlusDisplay.remove();
            }

            const sortedCharacters = [...CHARACTERS_LIST].sort((a,b) => b.health - a.health); 

            sortedCharacters.forEach(char => { 
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card'; 
                
                const isSelectedByMe = localGameState?.playerDetails[playerId]?.character?.id === char.id;
                let charHealth = char.health - ngPlusLevel > 0 ? char.health - ngPlusLevel : 1; 

                cardDiv.innerHTML = `
                    ${isSelectedByMe ? `<div class="absolute top-1 right-1 bg-green-700 text-white text-xs px-1.5 py-0.5 rounded-full" style="font-family: 'Special Elite', monospace; transform: rotate(10deg);"></div>` : ''}
                    <div class="card-name py-4">${char.name}</div>
                    <div class="card-bottom-text threat-health">HP: ${charHealth}</div>
                `;
                cardDiv.onclick = () => selectCharacter(char);
                if (isSelectedByMe) {
                    cardDiv.classList.add('selected');
                } 
                ui.characterSelection.appendChild(cardDiv);
            });

            if(ngPlusLevel > 0) {
                const ngPlusDisplay = document.createElement('p');
                ngPlusDisplay.id = 'ngPlusDisplay';
                ngPlusDisplay.className = "text-center text-yellow-300 font-western text-2xl mt-4";
                ngPlusDisplay.textContent = `NG+${ngPlusLevel}`;
                ui.characterSelection.insertAdjacentElement('afterend', ngPlusDisplay);
            }
        }

        function selectCharacter(character) {
            if (!localGameState || localGameState.status !== 'setup') return;
            
            const pDetails = localGameState.playerDetails[playerId];
            pDetails.character = character;
            
            renderCharacterSelection(); 
            
            updateCharacterDescription(character);
            ui.namePrompt.classList.remove('hidden');
            ui.startGameButton.classList.add('hidden'); 
        }

        function confirmName() {
            const pDetails = localGameState.playerDetails[playerId];
            const nameInput = ui.characterNameInput;
            if (nameInput.value.trim()) {
                pDetails.name = nameInput.value.trim();
                _log(`Your name is now ${pDetails.name}.`, 'system');
                ui.namePrompt.classList.add('hidden');
                ui.startGameButton.classList.remove('hidden'); 
            } else {
                showModal("Hold Your Horses!", "Please enter a name for your character.");
            }
        }

        async function startGame() {
            const pDetails = localGameState.playerDetails[playerId];
            if (!pDetails.character) {
                showModal("Wait, Cowboy!", "You need to select a character first.");
                return;
            }
            if (!pDetails.name) {
                showModal("What's in a Name?", "You need to confirm a name for your legend!");
                return;
            }
            
            const character = pDetails.character;
            pDetails.health = character.health;
            pDetails.maxHealth = character.health;
            pDetails.gold = character.gold || 10;
            
            const starterDeckIds = character.starterDeck || [];
            const starterDeck = starterDeckIds.map(id => ({...ALL_CARDS_DATA[id], id}));
            let currentDeckFiltered = pDetails.playerDeck.filter(card => !starterDeckIds.includes(card.id));
            const randomFillCount = 18 - starterDeck.length; 
            const randomFill = shuffleArray(currentDeckFiltered).slice(0, Math.max(0, randomFillCount));
            pDetails.playerDeck = shuffleArray([...starterDeck, ...randomFill]);

            const ngPlusLevel = parseInt(localStorage.getItem('ngPlusLevel') || '0');
            pDetails.health = Math.max(1, pDetails.health - ngPlusLevel);
            pDetails.maxHealth = Math.max(1, pDetails.maxHealth - ngPlusLevel);


            pDetails.hand = pDetails.playerDeck.splice(0, HAND_LIMIT); 
            pDetails.isUnsortedDraw = true; // Sort initial hand
            
            localGameState.status = 'playing';
            
            _log(`Game started with ${pDetails.name} the ${character.name}.`, 'system');
            _log(`Day 1 begins!`, 'turn');
            
            updateUIFromGameState();
            await drawAndResolveEvent(); 
            updateUIFromGameState(); 
        }
       
        function updateUIFromGameState() {
            if (!localGameState) return;

            if (localGameState.status === 'setup') {
                ui.gameSetup.style.display = 'block';
                ui.gameArea.style.display = 'none';
                renderCharacterSelection();
            } else if (localGameState.status === 'playing' || localGameState.status === 'finished') {
                ui.gameSetup.style.display = 'none';
                ui.gameArea.style.display = 'block';
               
                const myDetails = localGameState.playerDetails[playerId];
                if (myDetails) { 
                    ui.p1.name.textContent = myDetails.name || myDetails.character?.name || 'Player';
                    ui.p1.character.textContent = myDetails.character?.name || 'N/A';
                    ui.p1.health.textContent = `${myDetails.health} / ${myDetails.maxHealth}`;
                    ui.p1.gold.textContent = myDetails.gold || 0; 
                    ui.p1.handCount.textContent = `${myDetails.hand?.length}/${myDetails.handSize || HAND_LIMIT}`;
                    ui.p1.equippedCount.textContent = `${myDetails.equippedItems?.length}/${myDetails.equipSlots || EQUIP_LIMIT}`;
                   
                    const totalCards = (myDetails.playerDeck?.length || 0) + (myDetails.playerDiscard?.length || 0) + (myDetails.hand?.length || 0);
                    ui.playerDeckTotalCount.textContent = totalCards;
                    ui.playerDeckCount.textContent = myDetails.playerDeck?.length || 0;
                    ui.playerDiscardCount.textContent = myDetails.playerDiscard?.length || 0;

                    if (myDetails.activeTrap) {
                        ui.activeTrapDisplay.textContent = `Trap: ${myDetails.activeTrap.name}`;
                    } else {
                        ui.activeTrapDisplay.textContent = 'Trap: None';
                    }

                    renderPlayerHand(ui.p1.handDisplay, myDetails.hand);
                    renderPlayerEquippedItems(ui.p1.equippedDisplay, myDetails.equippedItems || [], myDetails.equipSlots || EQUIP_LIMIT);
                }

                ui.eventDeckCount.textContent = localGameState.eventDeck?.length || 0;
                ui.storeItemDeckCount.textContent = localGameState.storeItemDeck?.length || 0;
               
                renderStoreDisplay(ui.storeDisplay, localGameState.storeDisplayItems || []);

                if(localGameState.activeEvent) {
                    const event = localGameState.activeEvent;
                    const isTakeableItem = event.type !== 'Event'; 
                    const cardDiv = ui.activeEventCard;
                    
                    let cardTintClass = 'tint-red'; 
                    if(event.type === 'Item') cardTintClass = 'tint-gold';
                    else if(event.type === 'Provision') cardTintClass = 'tint-green';
                    else if(event.type === 'Action') cardTintClass = 'tint-blue';
                    cardDiv.className = `card ${cardTintClass}`;
                    
                    let displayableDamageValue = null;
                    if (event.effect?.type === 'damage_percent' && event.type === 'Event' && event.effect.amount > 0) {
                         displayableDamageValue = '50%';
                    } else if (event.type === 'Event' && (event.effect?.damage > 0 || event.effect?.amount > 0) && (event.effect.type === 'damage' || event.effect.type === 'poison' || event.effect.type === 'conditional_damage')) {
                        displayableDamageValue = event.effect.damage || event.effect.amount;
                    }
                   
                    let eventHtml = `
                        ${event.goldValue && event.type === 'Event' ? `<div class="card-top-left">${event.goldValue}G</div>` : ''}
                        ${displayableDamageValue ? `<div class="card-top-right">${displayableDamageValue}${event.effect?.type !== 'damage_percent' ? ' AT' : ''}</div>` : ''}
                        <div class="card-content-wrapper">
                            <div class="card-name">${event.name}</div>
                            <div class="card-type">${event.type} ${event.subType ? `- ${event.subType}` : ''}</div>
                        </div>
                        `;
                       
                    if (typeof event.health === 'number' && event.type === 'Event') { 
                        eventHtml += `<div class="card-bottom-text threat-health">Health: ${event.health}</div>`;
                    }
                    if (isTakeableItem) {
                        eventHtml += `<div id="takeEventButtonContainer" class="absolute bottom-2 left-0 right-0"></div>`;
                    }
                    cardDiv.innerHTML = eventHtml;

                    if(isTakeableItem) {
                        const takeButton = document.createElement('button');
                        takeButton.textContent = 'Take';
                        takeButton.className = 'action-btn';
                        takeButton.onclick = () => handleTakeEventItem(event);
                        const container = cardDiv.querySelector('#takeEventButtonContainer');
                        if(container) container.appendChild(takeButton);
                    }
                    ui.eventDescription.innerHTML = `
                        <p class="font-bold text-stone-800">${event.name}</p>
                        <p class="text-sm italic text-stone-600 mb-2">${event.type} ${event.subType ? `- ${event.subType}` : ''}</p>
                        <p>${event.description || ''}</p>
                        ${getFormattedEffectText(event, 'event') ? `<p class="mt-2 font-semibold">Effect: ${getFormattedEffectText(event, 'event')}</p>` : ''}
                    `;

                } else {
                    const quietMessages = [
                        "The trail is quiet... for now.", "An eerie silence hangs in the air.",
                        "You hear nothing but the wind and the dust.", "The path ahead is clear. A rare moment of peace.",
                        "You take a moment to catch your breath. The coast is clear."
                    ];
                    const message = quietMessages[Math.floor(Math.random() * quietMessages.length)];
                    ui.activeEventCard.innerHTML = `<div class="card-content-wrapper"><div class="card-name">All Clear</div></div>`;
                    ui.activeEventCard.className = `card`; 
                    ui.eventDescription.innerHTML = `<p class="text-stone-600 italic text-center p-4">${message}</p>`;
                }
               
                ui.turnNumberDisplay.textContent = localGameState.turn; 
                ui.endTurnButton.disabled = localGameState.status === 'finished' || localGameState.playerDetails[playerId].turnEnded;
                ui.restockButton.disabled = localGameState.playerDetails[playerId].hasRestockedThisTurn || localGameState.playerDetails[playerId].gold < 1;
            } 
            if (localGameState.status === 'finished' && !localGameState.endSequenceTriggered) {
                localGameState.endSequenceTriggered = true; 
                const isVictory = localGameState.playerDetails[playerId].health > 0;
                handleEndGameSequence(isVictory);
            }
            renderGameLog();
        }
       
        function deselectAllCards() {
            document.querySelectorAll('.card.selected').forEach(card => card.classList.remove('selected'));
            if(ui.cardDescription) ui.cardDescription.classList.add('hidden');
        }
       
        function renderPlayerHand(handDisplayElement, handCards) {
            if (!handDisplayElement) return;
            handDisplayElement.innerHTML = '';
            if (!handCards) return;
            
            const getCardCategory = (card) => { 
                if (!card) return 5; 
                if (card.type === 'Player Upgrade') return 1;
                if (card.effect?.type === 'weapon' || card.effect?.type === 'conditional_weapon') return 2;
                if (card.type === 'Provision') return 3;
                if (card.type === 'Action') return 4;
                return 5; 
            };
            if(localGameState.playerDetails[playerId].isUnsortedDraw){ 
                handCards.sort((a, b) => {
                    const categoryA = getCardCategory(a);
                    const categoryB = getCardCategory(b);
                    if (categoryA !== categoryB) return categoryA - categoryB;
                    const valueA = a.sellValue || a.buyCost || 0;
                    const valueB = b.sellValue || b.buyCost || 0;
                    return valueB - valueA; 
                });
                localGameState.playerDetails[playerId].isUnsortedDraw = false;
            }


            handCards.forEach((card, index) => { 
                const cardDiv = document.createElement('div');
                cardDiv.className = `card`; 
                if (card.type === 'Provision') cardDiv.classList.add('tint-green');
                else if (card.type === 'Action') cardDiv.classList.add('tint-blue');
                else if (card.type === 'Item' || card.type === 'Player Upgrade') cardDiv.classList.add('tint-gold');
                else if (card.type === 'Trophy' || card.type === 'Bounty Proof') cardDiv.classList.add('tint-grey');

                cardDiv.dataset.cardId = card.id + '_' + index; 
                
                const { damage, gold } = getCardValues(card, 'hand');

                cardDiv.innerHTML = `
                    ${gold ? `<div class="card-top-left">${gold}</div>` : ''}
                    ${damage ? `<div class="card-top-right">${damage}</div>` : ''}
                    <div class="card-content-wrapper">
                        <div class="card-name">${card.name}</div>
                        <div class="card-type">${card.type}</div> 
                    </div>
                    <div class="card-actions"></div>
                `;
               
                cardDiv.onclick = (e) => {
                    e.stopPropagation();
                    const isSelected = cardDiv.classList.contains('selected');
                    deselectAllCards();
                    if (!isSelected) {
                        cardDiv.classList.add('selected');
                        populateCardActions(cardDiv, card, 'hand', index);
                        updateCardDescription(card, 'hand');
                    }
                };
               
                handDisplayElement.appendChild(cardDiv);
            });
        }

        function renderPlayerEquippedItems(equippedDisplayElement, equippedItemsArray, equipSlots) {
            if (!equippedDisplayElement) return;
            equippedDisplayElement.innerHTML = '';
            const items = equippedItemsArray || []; 
           
            for (let i = 0; i < equipSlots; i++) {
                if (items[i]) {
                    const card = items[i];
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card equipped-card tint-gold'; 
                    cardDiv.dataset.cardId = card.id + '_' + i;

                    const { damage, gold } = getCardValues(card, 'equipped');
                    
                    cardDiv.innerHTML = `
                         ${gold ? `<div class="card-top-left">${gold}</div>` : ''}
                         ${damage ? `<div class="card-top-right">${damage}</div>` : ''}
                        <div class="card-content-wrapper">
                            <div class="card-name">${card.name}</div>
                            <div class="card-type">${card.type}</div>
                        </div>
                        <div class="card-actions"></div>
                    `;
                   
                    cardDiv.onclick = (e) => {
                        e.stopPropagation();
                        const isSelected = cardDiv.classList.contains('selected');
                        deselectAllCards();
                        if (!isSelected) {
                            cardDiv.classList.add('selected');
                            populateCardActions(cardDiv, card, 'equipped', i);
                            updateCardDescription(card, 'equipped');
                        }
                    };
                    
                    equippedDisplayElement.appendChild(cardDiv);
                } else {
                    const emptySlotDiv = document.createElement('div');
                    emptySlotDiv.className = 'equipped-slot';
                    emptySlotDiv.textContent = `Equip Slot`;
                    equippedDisplayElement.appendChild(emptySlotDiv);
                }
            }
        }

        function renderStoreDisplay(storeDisplayElement, storeItemsArray) {
            if (!storeDisplayElement) return;
            storeDisplayElement.innerHTML = '';
            const items = storeItemsArray || [];

            for (let i = 0; i < STORE_DISPLAY_LIMIT; i++) {
                const slotDiv = document.createElement('div'); 
                if (items[i]) {
                    const card = items[i];
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card store-item-card';
                    if (card.type === 'Provision') cardDiv.classList.add('tint-green');
                    else if (card.type === 'Action') cardDiv.classList.add('tint-blue');
                    else if (card.type === 'Item' || card.type === 'Player Upgrade') cardDiv.classList.add('tint-gold');
                    cardDiv.dataset.cardId = card.id + '_' + i;
                    
                    const { damage, gold: buyCostDisplay } = getCardValues(card, 'store'); 
                    
                    cardDiv.innerHTML = `
                        ${buyCostDisplay ? `<div class="card-top-left">${buyCostDisplay}</div>` : ''} 
                        ${damage ? `<div class="card-top-right">${damage}</div>` : ''} 
                        <div class="card-content-wrapper">
                            <div class="card-name">${card.name}</div>
                            <div class="card-type">${card.type}</div>
                        </div>
                        <div class="card-bottom-text buy-cost">Cost: ${card.buyCost || 'N/A'}G</div>
                        <div class="card-actions"></div>
                    `;
                   
                    cardDiv.onclick = (e) => {
                        e.stopPropagation();
                        const isSelected = cardDiv.classList.contains('selected');
                        deselectAllCards();
                        if (!isSelected) {
                            cardDiv.classList.add('selected');
                            populateCardActions(cardDiv, card, 'store', i);
                            updateCardDescription(card, 'store');
                        }
                    };
                    
                    slotDiv.appendChild(cardDiv);
                } else {
                    slotDiv.innerHTML = `<div class="equipped-slot" style="height: 10.5rem; width: 7.5rem;">Sold Out</div>`; 
                }
                storeDisplayElement.appendChild(slotDiv);
            }
        }
        
        function isEventConsideredHostile(eventCard) {
            if (!eventCard) return false;
            if (eventCard.type !== 'Event') return false; 

            if (eventCard.id === 'threat_rabbit' || eventCard.id === 'threat_squirrel') return false;

            const effect = eventCard.effect;
            if (effect) {
                if (effect.type === 'lose_gold' && (effect.amount || 0) > 0) return true;
                if (effect.type === 'discard_equipped') return true;
                if (effect.type === 'damage_percent' && (effect.amount || 0) > 0) return true;

                if ((effect.type === 'damage' || effect.type === 'poison' || effect.type === 'conditional_damage') && (effect.amount > 0 || effect.damage > 0)) {
                    // Specifically exempt Beaver if its current damage is 0 from conditional_damage
                    if (eventCard.id === 'threat_beaver' && (effect.damage === 0 && effect.amount === 0) ) return false;
                    return true;
                }
            }
            
            // If it has health AND its base effect implies damage
            if (typeof eventCard.health === 'number' && eventCard.health > 0) {
                if (effect && (effect.type === 'damage' || effect.type === 'poison') && (effect.amount > 0 || effect.damage > 0)) {
                    return true;
                }
                if (effect && effect.type === 'conditional_damage' && (effect.damage > 0 || effect.amount > 0) && eventCard.id !== 'threat_beaver') return true;
                 // For Beaver, already handled above: if conditional_damage is 0, not hostile for trading.
            }
            return false; 
        }


        function populateCardActions(cardDiv, card, source, index) {
            const container = cardDiv.querySelector('.card-actions');
            container.innerHTML = '';
            if (!localGameState) return;
            const myDetails = localGameState.playerDetails[playerId];

            const createBtn = (text, handler, disabled = false) => {
                const btn = document.createElement('button');
                btn.className = 'action-btn';
                btn.textContent = text;
                btn.disabled = disabled;
                btn.onclick = (e) => {
                    e.stopPropagation();
                    deselectAllCards();
                    handler();
                };
                return btn;
            };

            if (myDetails.turnEnded && source !== 'store') return;

            const blockTradeDueToHostileEvent = isEventConsideredHostile(localGameState.activeEvent);
            
            const usableEffects = ['heal', 'weapon', 'conditional_weapon', 'campfire', 'gold', 'draw', 'trap', 'escape', 'upgrade', 'fire_arrow', 'discard_gold', 'scout'];

            if (source === 'hand') {
                if (card.id === 'item_gold_nugget' || card.id === 'item_jewelry') {
                     container.appendChild(createBtn(`Sell ${card.sellValue}G`, () => handleSellItem(card, source, index), blockTradeDueToHostileEvent || myDetails.turnEnded));
                     return;
                }


                if (card.effect && usableEffects.includes(card.effect.type) && card.id !== 'upgrade_satchel') {
                    let useDisabled = myDetails.turnEnded;

                    if (card.effect.type === 'weapon' || card.effect.type === 'conditional_weapon' || card.effect.type === 'fire_arrow') {
                        if (!localGameState.activeEvent || localGameState.activeEvent.health <= 0 || localGameState.activeEvent.type !== 'Event') {
                            useDisabled = true;
                        }
                    }
                    if(card.effect.type === 'fire_arrow') {
                        const hasBow = myDetails.hand.some(c => c.id === 'item_bow') || myDetails.equippedItems.some(c => c.id === 'item_bow');
                        if (!hasBow) useDisabled = true;
                    }
                    if (card.effect.type === 'scout' && myDetails.hasTakenActionThisTurn) { 
                        useDisabled = true;
                    }
                    container.appendChild(createBtn('Play', () => handleUseItem(card, source, index), useDisabled));
                }

                if (card.type === 'Player Upgrade' || (card.type === 'Item' && card.effect && card.effect.type !== 'trap')) {
                    const equipSlotsFull = (myDetails.equippedItems?.length || 0) >= myDetails.equipSlots;
                    const canEquip = !myDetails.hasEquippedThisTurn && !equipSlotsFull && !myDetails.turnEnded;
                    container.appendChild(createBtn('Equip', () => handleEquip(card, index), !canEquip));
                }

                if (card.type === 'Provision') {
                    const satchel = myDetails.equippedItems.find(item => item.id === 'upgrade_satchel');
                    if (satchel) {
                        const canStore = (myDetails.satchel?.length || 0) < (satchel.effect.capacity || 3) && !myDetails.turnEnded;
                        container.appendChild(createBtn('Store', () => handleStoreProvision(card, index), !canStore));
                    }
                }
               
                const canSell = typeof card.sellValue === 'number' && card.sellValue > 0;
                if (canSell) {
                    container.appendChild(createBtn(`Sell ${card.sellValue}G`, () => handleSellItem(card, source, index), blockTradeDueToHostileEvent || myDetails.turnEnded));
                }
           
            } else if (source === 'equipped') {
                 if (myDetails.turnEnded) return;

                if (card.id === 'upgrade_satchel') {
                    const canUse = (myDetails.satchel?.length || 0) > 0;
                    container.appendChild(createBtn('Use from Satchel', () => handleUseFromSatchel(), !canUse));
                } else if (card.effect && usableEffects.includes(card.effect.type)) {
                     let useEquippedDisabled = false;
                     if (card.effect.type === 'weapon' || card.effect.type === 'conditional_weapon' || card.effect.type === 'fire_arrow') {
                        if (!localGameState.activeEvent || localGameState.activeEvent.health <= 0 || localGameState.activeEvent.type !== 'Event') {
                            useEquippedDisabled = true;
                        }
                    }
                    container.appendChild(createBtn('Play', () => handleUseItem(card, source, index), useEquippedDisabled));
                }
                if (card.type === 'Player Upgrade') {
                    container.appendChild(createBtn('Discard', () => handleDiscardUpgrade(card, index)));
                } else if (card.type === 'Item'){
                     container.appendChild(createBtn('Discard', () => handleDiscardEquippedItem(card, index)));
                }

            } else if (source === 'store') {
                const canAfford = myDetails.gold >= (card.buyCost || 0);
                container.appendChild(createBtn(`Buy ${card.buyCost}G`, () => handleBuyItem(card, index), !canAfford || blockTradeDueToHostileEvent));
            }
        }

        function getFormattedEffectText(card, source = 'hand') {
            if (!card || !card.effect) return null;
        
            const effect = card.effect;
            switch (effect.type) {
                case 'heal':
                    return `Heals ${effect.amount} HP${effect.cures ? ' & Cures Illness' : ''}.`;
                case 'damage':
                     if (effect.amount > 0) return `Deals ${effect.amount} damage.`;
                     return null;
                case 'weapon':
                    return `Attack Power: ${effect.attack}.`;
                case 'conditional_weapon':
                    return `Attack: ${effect.attack} (Bonus: +${effect.bonus_attack} if ${effect.condition === 'is_firearm' ? 'another firearm in hand' : 'condition met'}).`;
                 case 'conditional_damage': 
                    if (effect.damage > 0) return `Deals ${effect.damage} damage if ${effect.condition === 'item_wood' ? 'you have Firewood' : effect.condition}.`;
                    return `No immediate damage unless condition is met.`; 
                case 'draw':
                    return `Draw ${effect.amount} card${effect.amount > 1 ? 's' : ''}.`;
                case 'trap':
                    return `Sets a ${effect.size} trap.`;
                case 'campfire':
                    return `Builds a campfire for the night.`;
                case 'gold':
                    if (card.id !== 'item_gold_nugget' && card.id !== 'item_jewelry') { 
                       return `Gain ${effect.amount} Gold.`;
                    }
                    return null;
                case 'scout':
                    return `Reveals the next event.`;
                case 'fire_arrow':
                    return `Requires a Bow. Adds bonus damage.`;
                case 'upgrade':
                    if (effect.subtype === 'max_health') return `Increases Max HP by ${effect.amount}.`;
                    if (effect.subtype === 'bow_boost') return `Bow Attacks +${effect.amount}.`;
                    if (effect.subtype === 'knife_boost') return `Knife Attacks +${effect.amount}.`;
                    if (effect.subtype === 'firearm_boost') return `Firearm Attacks +${effect.amount}.`;
                    if (effect.subtype === 'provision_heal_boost') return `Healing Provisions +${effect.amount}.`;
                    if (effect.subtype === 'herb_boost') return `Herbal Provisions +${effect.amount}.`;
                    if (effect.subtype === 'sell_boost') return `Sell Value of cards +${effect.amount}G.`;
                    if (effect.subtype === 'damage_reduction') return `Reduces incoming damage by ${effect.amount}.`;
                    if (effect.subtype === 'storage') return `Satchel: Stores up to ${effect.capacity} provisions.`;
                    if (effect.subtype === 'double_fire') return `Allows firing twice with firearms.`;
                    if (effect.subtype === 'damage_negation') return `Negates one hit, +${effect.max_health} Max HP.`;
                    return `Provides a persistent upgrade.`;
                default:
                    return null;
            }
        }
        
        function updateCardDescription(card, source) {
            let desc = '';
            if (!card || !ui.cardDescription) {
                if(ui.cardDescription) ui.cardDescription.innerHTML = 'Select a card to see its details.';
                return;
            }
            ui.cardDescription.classList.remove('hidden');

            desc += `<p class="font-bold text-lg text-stone-800">${card.name}</p>`;
            desc += `<p class="text-sm italic text-stone-600 mb-2">${card.type} ${card.subType ? `- ${card.subType}` : ''}</p>`;
            desc += `<p>${card.description || 'No description available.'}</p>`;
            
            if (source === 'store' && card.buyCost) {
                desc += `<p class="mt-2 font-semibold">Cost: ${card.buyCost} Gold</p>`;
            } else if (source === 'hand' && card.sellValue && (card.id === 'item_gold_nugget' || card.id === 'item_jewelry' || card.type === 'Trophy' || card.type === 'Bounty Proof')) {
                 desc += `<p class="mt-2 font-semibold">Sell Value: ${card.sellValue} Gold</p>`;
            } else if (source === 'hand' && card.sellValue && card.id !== 'item_gold_nugget' && card.id !== 'item_jewelry') {
                 desc += `<p class="mt-1 text-xs">Sell for: ${card.sellValue}G</p>`;
            }

            const effectText = getFormattedEffectText(card, source);
            if (effectText) {
                desc += `<p class="mt-2 font-semibold">Effect: ${effectText}</p>`;
            }
            
            ui.cardDescription.innerHTML = desc;
        }

        function updateCharacterDescription(character) {
            let desc = '';
            if (!character || !ui.characterDescription) {
                 if(ui.characterDescription) ui.characterDescription.innerHTML = 'Select a character to see their details.';
                return;
            }
            const ngPlusLevel = parseInt(localStorage.getItem('ngPlusLevel') || '0');
            let charHealth = character.health - ngPlusLevel > 0 ? character.health - ngPlusLevel : 1;


            desc += `<p class="font-bold text-lg text-stone-800">${character.name}</p>`;
            desc += `<p class="text-sm italic text-stone-600 mb-2">Health: ${charHealth}, Gold: ${character.gold}</p>`;
            desc += `<p>${character.ability}</p>`;
            
            const starterDeckNames = character.starterDeck.map(id => ALL_CARDS_DATA[id]?.name || 'Unknown Card').join(', ');
            desc += `<p class="mt-2 font-semibold">Starts with:</p><p class="text-xs">${starterDeckNames}</p>`;

            ui.characterDescription.innerHTML = desc;
        }


        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
       
        async function resetGame() {
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "AIzaSyCa7ymQSXzZuJbNbXB-xTVGZ0UqmFeCESo") { // User's existing key check
                console.warn("Gemini API key not set. AI features disabled.");
            }
            isEndingTurn = false;
            localGameState = null; 
            if(document.getElementById('storyModal')) document.getElementById('storyModal').classList.add('hidden');
            if(document.getElementById('scoutedCardContainer')) document.getElementById('scoutedCardContainer').classList.remove('visible');

            if(ui.gameArea) ui.gameArea.style.display = 'none';
            if(ui.gameSetup) ui.gameSetup.style.display = 'block';
            if(ui.namePrompt) ui.namePrompt.classList.add('hidden');
            if(ui.startGameButton) ui.startGameButton.classList.add('hidden');
            
            if(ui.characterSelection) ui.characterSelection.innerHTML = `<p class="text-stone-200 text-center col-span-full">Preparing the frontier...</p>`;

            const savedDeckJSON = localStorage.getItem('wildWestWinDeck');
            
            localGameState = await createInitialGameState(savedDeckJSON ? JSON.parse(savedDeckJSON) : null);
            
            if (savedDeckJSON) {
                localStorage.removeItem('wildWestWinDeck'); 
                const ngPlusLevel = parseInt(localStorage.getItem('ngPlusLevel') || '0'); 
                _log(`Starting New Game+ ${ngPlusLevel}! Your previous victories echo...`, "system");
            } else {
                if (!localGameState.ngPlusLevel || localGameState.ngPlusLevel === 0) {
                     _log("New game started. Choose your legend.", 'system');
                }
            }
            
            updateUIFromGameState();
        }

        document.addEventListener('DOMContentLoaded', () => {
            ui = {
                app: document.getElementById('app'),
                gameSetup: document.getElementById('gameSetup'),
                gameArea: document.getElementById('gameArea'),
                characterSelection: document.getElementById('characterSelection'),
                startGameButton: document.getElementById('startGameButton'),
                restartButton: document.getElementById('restartButton'),
                restockButton: document.getElementById('restockButton'),
                namePrompt: document.getElementById('namePrompt'),
                characterNameInput: document.getElementById('characterNameInput'),
                confirmNameButton: document.getElementById('confirmNameButton'),
                gameLog: document.getElementById('gameLog'),
                cardDescription: document.getElementById('cardDescription'),
                characterDescription: document.getElementById('characterDescription'),
                eventDescription: document.getElementById('eventDescription'),
                scoutedCardContainer: document.getElementById('scoutedCardContainer'),
                p1: {
                    area: document.getElementById('player1Area'),
                    name: document.getElementById('player1Name'),
                    character: document.getElementById('player1Character'),
                    health: document.getElementById('player1Health'),
                    gold: document.getElementById('player1Gold'), 
                    handCount: document.getElementById('player1HandCount'),
                    handDisplay: document.getElementById('player1HandDisplay'),
                    equippedDisplay: document.getElementById('player1EquippedDisplay'), 
                    equippedCount: document.getElementById('player1EquippedCount') 
                },
                playerDeckCount: document.getElementById('playerDeckCount'),
                playerDeckTotalCount: document.getElementById('playerDeckTotalCount'),
                playerDiscardCount: document.getElementById('playerDiscardCount'),
                eventDeckCount: document.getElementById('eventDeckCount'),
                activeEventCard: document.getElementById('activeEventCard'),
                activeTrapDisplay: document.getElementById('activeTrapDisplay'),
                turnNumberDisplay: document.getElementById('turnNumberDisplay'), 
                endTurnButton: document.getElementById('endTurnButton'),
                storeDisplay: document.getElementById('storeDisplay'),
                storeItemDeckCount: document.getElementById('storeItemDeckCount'),
                messageModal: {
                    overlay: document.getElementById('messageModal'),
                    title: document.getElementById('messageModalTitle'),
                    text: document.getElementById('messageModalText'),
                    closeButton: document.getElementById('messageModalCloseButton')
                },
                storyModal: {
                    overlay: document.getElementById('storyModal'),
                    title: document.getElementById('storyModalTitle'),
                    text: document.getElementById('storyModalText'),
                    closeButton: document.getElementById('storyModalCloseButton')
                },
                endGameBanner: document.getElementById('endGameBanner'), 
                endGameText: document.getElementById('endGameText') 
            };
           
            ui.app.addEventListener('click', (e) => {
                if (!e.target.closest('.card') && !e.target.closest('.scouted-card-preview-container')) { 
                    deselectAllCards();
                }
            });

            ui.restartButton.onclick = () => {
                showModal("Restart Game?", "Are you sure you want to abandon this run and start over? Any NG+ progress will be reset.", () => {
                    localStorage.removeItem('wildWestWinDeck'); 
                    localStorage.setItem('ngPlusLevel', '0'); 
                    resetGame();
                });
            };
            ui.storyModal.closeButton.onclick = () => { 
                ui.storyModal.overlay.classList.add('hidden'); 
                const overlay = document.getElementById('endGameOverlay');
                if(overlay) overlay.style.opacity = '0'; 
                resetGame(); 
            };
            ui.startGameButton.onclick = startGame;
            ui.confirmNameButton.onclick = confirmName;
            ui.endTurnButton.onclick = endTurn;
            ui.messageModal.closeButton.onclick = () => ui.messageModal.overlay.classList.add('hidden');
            ui.restockButton.onclick = handleRestockStore;

            resetGame(); 
        });

        async function resolveTrap(playerDetails, state) {
            if (!playerDetails.activeTrap) return false;
        
            const nextCard = state.eventDeck[state.eventDeck.length - 1]; 
            if (!nextCard || nextCard.type !== 'Event') { 
                _log("Trap is set, but the path ahead is clear of immediate threats.", 'system');
                return false;
            }

            const trap = playerDetails.activeTrap;
            const trapSize = trap.effect.size;
            const isAnimal = nextCard.subType === 'animal';
            const isHuman = nextCard.subType === 'human';
            let trapSprung = false;
            let creatureEscaped = false;

            if (isAnimal) {
                const caughtAnimal = state.eventDeck.pop(); 
                trapSprung = true;
                
                if (trapSize === 'small') {
                    if (caughtAnimal.health <= 2) { 
                        _log(`Your small trap caught and defeated the ${caughtAnimal.name}!`, 'system');
                        const trophy = { name: `${caughtAnimal.name} Pelt`, type: 'Trophy', sellValue: caughtAnimal.goldValue, id: `trophy_${caughtAnimal.id}_${Date.now()}` };
                        playerDetails.playerDiscard.push(trophy);
                    } else {
                         _log(`Your small trap was not strong enough for the ${caughtAnimal.name}. It breaks, and the creature is now active!`, 'system');
                         state.activeEvent = caughtAnimal; 
                         creatureEscaped = true;
                    }
                } else if (trapSize === 'large') {
                    const damageDealt = 8; 
                    caughtAnimal.health -= damageDealt;
                    _log(`Your large trap injured the ${caughtAnimal.name} for ${damageDealt} damage!`, 'system');
                    await triggerThreatDamageFlash(damageDealt);
                    if (caughtAnimal.health <= 0) {
                        _log(`The ${caughtAnimal.name} succumbed to its wounds.`, 'system');
                        const trophy = { name: `Large ${caughtAnimal.name} Trophy`, type: 'Trophy', sellValue: caughtAnimal.goldValue * 2, id: `trophy_${caughtAnimal.id}_${Date.now()}` };
                        playerDetails.playerDiscard.push(trophy);
                    } else {
                        _log(`The wounded ${caughtAnimal.name} is now active!`, 'system');
                        state.activeEvent = caughtAnimal; 
                        creatureEscaped = true;
                    }
                }
            } else if(isHuman && nextCard.health > 0) { 
                 const sprungThreat = state.eventDeck.pop();
                 _log(`Your trap was sprung by a ${sprungThreat.name}, but it only angered them!`, 'system');
                 sprungThreat.health = Math.max(1, sprungThreat.health - 1); 
                 state.activeEvent = sprungThreat;
                 trapSprung = true;
                 creatureEscaped = true; 
            }
            
            if (trapSprung) {
                playerDetails.playerDiscard.push(trap); 
                playerDetails.activeTrap = null;
                return !creatureEscaped; 
            }
            
             return false; 
        }
        
        async function endTurn() {
            if (isEndingTurn || !localGameState || localGameState.status === 'finished') return;
            isEndingTurn = true;
            const p = localGameState.playerDetails[playerId];
            p.turnEnded = true; 
            updateUIFromGameState(); 

            try {
                deselectAllCards(); 
                
                const activeThreatAtTurnStart = localGameState.activeEvent;
                const canRestHeal = (!activeThreatAtTurnStart || 
                                   activeThreatAtTurnStart.health <= 0 || 
                                   (p.isCampfireActive && activeThreatAtTurnStart.subType === 'animal')) &&
                                   !p.wasDamagedOrNegativelyAffectedThisTurn;

                if (canRestHeal && p.health < p.maxHealth) {
                    p.health = Math.min(p.maxHealth, p.health + 1);
                    _log("You rest and recover 1 health.", "system");
                    await triggerHealFlash(1);
                }

                p.playerDiscard.push(...p.hand);
                p.hand = [];
                updateUIFromGameState(); 
                await delay(300);

                if (activeThreatAtTurnStart && activeThreatAtTurnStart.health > 0) {
                    const isAnimalThreat = activeThreatAtTurnStart.subType === 'animal';
                    if (p.isCampfireActive && isAnimalThreat) {
                       _log(`The campfire keeps the ${activeThreatAtTurnStart.name} at bay. No attack this night.`, 'system');
                    } else if (!p.isCampfireActive || !isAnimalThreat) { 
                        let effectiveDamage = 0;
                        if (activeThreatAtTurnStart.effect?.type === 'conditional_damage' && activeThreatAtTurnStart.id === 'threat_beaver') {
                             effectiveDamage = activeThreatAtTurnStart.effect.damage || 0; 
                        } else {
                            effectiveDamage = activeThreatAtTurnStart.effect?.damage || activeThreatAtTurnStart.effect?.amount || 0;
                        }

                        if(effectiveDamage > 0) {
                            _log(`${activeThreatAtTurnStart.name} attacks!`, 'event');
                            dealPlayerDamage(p, effectiveDamage, localGameState, activeThreatAtTurnStart.name);
                            if (localGameState.status === 'finished') { isEndingTurn = false; updateUIFromGameState(); return; }
                        }
                    }
                }
                
                if (p.isCampfireActive) {
                    _log("The campfire smoke hides you from new perils tonight.", 'system');
                    if (localGameState.activeEvent && localGameState.activeEvent.type !== 'Event') { 
                        _log(`The ${localGameState.activeEvent.name} was left behind in the gloom.`, 'system');
                        localGameState.eventDiscardPile.push(localGameState.activeEvent);
                        localGameState.activeEvent = null;
                    }
                } else { 
                     if (localGameState.activeEvent) {
                        if (localGameState.activeEvent.health <= 0) { 
                            // Already handled
                        } else if (localGameState.activeEvent.type === 'Event' && !isEventConsideredHostile(localGameState.activeEvent)) {
                            _log(`${localGameState.activeEvent.name} wanders off, uninterested.`, 'system');
                            localGameState.eventDiscardPile.push(localGameState.activeEvent);
                            localGameState.activeEvent = null;
                        } else if (localGameState.activeEvent.type !== 'Event' && localGameState.activeEvent.id !== 'item_gold_nugget' && localGameState.activeEvent.id !== 'item_jewelry') { 
                            _log(`The ${localGameState.activeEvent.name} was left behind.`, 'system');
                            localGameState.eventDiscardPile.push(localGameState.activeEvent);
                            localGameState.activeEvent = null;
                        }
                    }

                    if (!localGameState.activeEvent) { 
                        let trapFullyResolvedNoNewThreat = await resolveTrap(p, localGameState);
                        if (!trapFullyResolvedNoNewThreat && !localGameState.activeEvent) {
                            await drawAndResolveEvent();
                        }
                    }
                }
                if (localGameState.status === 'finished') { isEndingTurn = false; updateUIFromGameState(); return; }

                for(let i = 0; i < p.handSize; i++){
                    if(p.playerDeck.length === 0 && p.playerDiscard.length > 0) {
                        _log("Reshuffling discard pile into deck.", "system");
                        p.playerDeck = shuffleArray(p.playerDiscard);
                        p.playerDiscard = [];
                    }
                    if(p.playerDeck.length > 0) p.hand.push(p.playerDeck.pop());
                }
                p.isUnsortedDraw = true; 

                p.isCampfireActive = false; 
                p.hasEquippedThisTurn = false;
                p.hasTakenActionThisTurn = false;
                p.hasRestockedThisTurn = false;
                p.wasDamagedOrNegativelyAffectedThisTurn = false; // Reset for next turn
                p.turnEnded = false; 
                localGameState.turn += 1;
                _log(`Day ${localGameState.turn} begins.`, 'turn');
               
            } catch (error) {
                console.error("Error during endTurn logic:", error);
                _log(`An error occurred: ${error.message}`, 'error');
            } finally {
                isEndingTurn = false;
                updateUIFromGameState(); 
            }
        }
        
        async function drawAndResolveEvent() {
            if (!localGameState) return;
            let p = localGameState.playerDetails[playerId];
            let eventFound = false;
            let attempts = 0; 

            while (!eventFound && attempts < (EVENT_DECK_SIZE * 2)) {
                attempts++;
                if (localGameState.eventDeck.length === 0) {
                    if (localGameState.eventDiscardPile.length > 0) {
                        localGameState.eventDeck = shuffleArray(localGameState.eventDiscardPile);
                        localGameState.eventDiscardPile = [];
                        _log("Event deck reshuffled.", "system");
                    } else {
                        _log("You've survived all the perils of the frontier!", "system");
                        localGameState.status = 'finished';
                        localGameState.winReason = "You survived the perils of the frontier!";
                        return; 
                    }
                }

                const newEvent = localGameState.eventDeck.pop();
                
                if ((newEvent.id === 'item_gold_nugget' || newEvent.id === 'item_jewelry') && newEvent.type === 'Item') {
                     _log(`You stumbled upon a ${newEvent.name}!`, 'event');
                     localGameState.activeEvent = newEvent;
                     eventFound = true; 
                } else if (newEvent.type === 'Item' && newEvent.effect?.type === 'gold') { 
                    p.gold += newEvent.effect.amount;
                    _log(`Fortune smiles! You found a ${newEvent.name} worth ${newEvent.effect.amount} gold.`, 'gold');
                    triggerGoldFlash();
                    localGameState.eventDiscardPile.push(newEvent); 
                } else { 
                    _log(`New Event: ${newEvent.name}`, 'event');
                    localGameState.activeEvent = newEvent;
                    await applyThreatEffect(newEvent, p, localGameState); 
                    eventFound = true; 
                }
            }
            if (attempts >= (EVENT_DECK_SIZE * 2)) {
                _log("The path ahead is unnaturally quiet... perhaps too quiet. (Event draw loop limit)", "system");
                localGameState.activeEvent = null; 
            }
        }

        async function handleEquip(card, index) {
            const p = localGameState.playerDetails[playerId];
            const [itemToEquip] = p.hand.splice(index, 1);
           
            if (itemToEquip.effect.type === 'upgrade' && itemToEquip.effect.subtype === 'max_health'){
                const healthBonus = itemToEquip.effect.amount || 0;
                p.maxHealth += healthBonus;
                p.health += healthBonus; 
            }
             if(itemToEquip.id.includes('hat') && itemToEquip.effect?.max_health) { 
                const healthBonus = itemToEquip.effect.max_health || 0;
                p.maxHealth += healthBonus;
                p.health += healthBonus;
             }

            p.equippedItems.push(itemToEquip);
            p.hasEquippedThisTurn = true;
            p.hasTakenActionThisTurn = true;
           
            _log(`Equipped ${itemToEquip.name}.`, 'action');
            updateUIFromGameState();
        }
        
        async function showScoutedCard(card) {
            if (!card || !ui.scoutedCardContainer) return;
        
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card'; 
            if (card.type === 'Event') cardDiv.classList.add('tint-red');
            else if (card.type === 'Item') cardDiv.classList.add('tint-gold');
            else if (card.type === 'Provision') cardDiv.classList.add('tint-green');
            else if (card.type === 'Action') cardDiv.classList.add('tint-blue');
        
            let displayableDamageValue = null;
            if (card.effect?.type === 'damage_percent' && card.type === 'Event' && card.effect.amount > 0) {
                displayableDamageValue = '50%';
            } else if (card.type === 'Event' && (card.effect?.damage > 0 || card.effect?.amount > 0) && (card.effect.type === 'damage' || card.effect.type === 'poison' || card.effect.type === 'conditional_damage')) {
                displayableDamageValue = card.effect.damage || card.effect.amount;
            }

            cardDiv.innerHTML = `
                ${card.goldValue && card.type === 'Event' ? `<div class="card-top-left">${card.goldValue}G</div>` : ''}
                ${displayableDamageValue ? `<div class="card-top-right">${displayableDamageValue}${card.effect?.type !== 'damage_percent' ? ' AT' : ''}</div>` : ''}
                <div class="card-content-wrapper">
                    <div class="card-name">${card.name}</div>
                    <div class="card-type">${card.type} ${card.subType ? `- ${card.subType}` : ''}</div>
                </div>
                ${(typeof card.health === 'number' && card.type === 'Event') ? `<div class="card-bottom-text threat-health">Health: ${card.health}</div>` : ''}
            `;
        
            ui.scoutedCardContainer.innerHTML = ''; 
            ui.scoutedCardContainer.appendChild(cardDiv);
            
            ui.scoutedCardContainer.classList.add('visible');
            await delay(5000); 
            ui.scoutedCardContainer.classList.remove('visible');
            await delay(500); 
            ui.scoutedCardContainer.innerHTML = ''; 
        }


        async function handleUseItem(card, source, index) {
            const p = localGameState.playerDetails[playerId];
            let usedCard;
            p.hasTakenActionThisTurn = true;

            if(source === 'hand') {
                [usedCard] = p.hand.splice(index, 1);
            } else { 
                [usedCard] = p.equippedItems.splice(index, 1);
                if (usedCard.effect?.subtype === 'max_health' && !usedCard.effect.persistent) {
                    p.maxHealth = Math.max(1, p.maxHealth - (usedCard.effect.amount || 0));
                    if (p.health > p.maxHealth) p.health = p.maxHealth;
                }
                if (usedCard.id.includes('hat') && usedCard.effect?.max_health && !usedCard.effect.persistent) {
                     p.maxHealth = Math.max(1, p.maxHealth - (usedCard.effect.max_health || 0));
                    if (p.health > p.maxHealth) p.health = p.maxHealth;
                }
            }

            switch(usedCard.effect.type) {
                case 'heal': {
                    const healAmount = calculateHealAmount(usedCard, p);
                    const oldHealth = p.health;
                    p.health = Math.min(p.maxHealth, p.health + healAmount);
                    const actualHeal = p.health - oldHealth;
                    _log(`Used ${usedCard.name} to heal for ${actualHeal}.`, 'action');
                    if (actualHeal > 0) {
                        await triggerHealFlash(actualHeal);
                    }
                    if (usedCard.effect.cures && localGameState.activeEvent && localGameState.activeEvent.subType === 'illness') {
                        _log(`${usedCard.name} cured the ${localGameState.activeEvent.name}!`, 'system');
                        localGameState.eventDiscardPile.push(localGameState.activeEvent);
                        localGameState.activeEvent = null;
                    }
                    break;
                }
                case 'draw': {
                    let newCardsDrawnNames = [];
                     for(let i=0; i < usedCard.effect.amount; i++){
                         if(p.hand.length < p.handSize){ 
                             if(p.playerDeck.length === 0 && p.playerDiscard.length > 0) {
                                _log("Reshuffling discard into deck to draw.", "system");
                                p.playerDeck = shuffleArray(p.playerDiscard);
                                p.playerDiscard = [];
                             }
                             if(p.playerDeck.length > 0) {
                                 const drawnCard = p.playerDeck.pop();
                                 p.hand.push(drawnCard);
                                 newCardsDrawnNames.push(drawnCard.name);
                             } else {
                                _log("Deck is empty, cannot draw more cards.", "system");
                                break;
                             }
                         } else {
                            _log("Hand is full, cannot draw more cards.", "system");
                            break;
                         }
                     }
                    if(newCardsDrawnNames.length > 0) _log(`Used ${usedCard.name} to draw: ${newCardsDrawnNames.join(', ')}.`, 'action');
                    else _log(`Used ${usedCard.name}, but no cards could be drawn.`, 'action');
                    p.isUnsortedDraw = true; 
                    break;
                }
                case 'weapon':
                case 'conditional_weapon':
                case 'fire_arrow': {
                    let attackPower;
                    if (usedCard.effect.type === 'fire_arrow') {
                        const bowInHand = p.hand.find(c => c.id === 'item_bow');
                        const bowEquipped = p.equippedItems.find(c => c.id === 'item_bow');
                        let bowUsedForArrow = null;

                        if (bowEquipped) { 
                            attackPower = calculateAttackPower(bowEquipped, p, 'equipped') + 2; 
                            bowUsedForArrow = bowEquipped; 
                             _log(`Firing a flaming arrow from your equipped ${bowUsedForArrow.name}! Total AT: ${attackPower}`, 'system');
                        } else if (bowInHand) { 
                            attackPower = calculateAttackPower(bowInHand, p, 'hand') + 1; 
                            bowUsedForArrow = bowInHand;
                             _log(`You quickly string a flaming arrow with your ${bowUsedForArrow.name}! Total AT: ${attackPower}`, 'system');
                            const bowIndex = p.hand.findIndex(c => c.id === bowUsedForArrow.id);
                            if (bowIndex > -1) {
                                const [discardedBow] = p.hand.splice(bowIndex, 1);
                                p.playerDiscard.push(discardedBow);
                                _log(`${discardedBow.name} was consumed firing the flaming arrow.`, 'system');
                            }
                        } else {
                            attackPower = 0; 
                            _log("You have no bow to fire these arrows with!", 'error');
                        }
                    } else { 
                        attackPower = calculateAttackPower(usedCard, p, source);
                    }

                    if (attackPower > 0 && localGameState.activeEvent && localGameState.activeEvent.health > 0 && localGameState.activeEvent.type === 'Event') {
                        const bandolier = p.equippedItems.find(item => item.id === 'upgrade_bandolier');
                        const firearms = ['item_sawed_off', 'item_rifle', 'item_six_shooter'];
                        const isFirearm = firearms.includes(usedCard.id) || (usedCard.effect.type === 'fire_arrow' && p.equippedItems.some(i => i.id === 'item_bow' && firearms.includes(i.id))); 
                        const attacks = (bandolier && isFirearm) ? 2 : 1;
                       
                        for (let i = 0; i < attacks; i++) {
                            if(localGameState.activeEvent && localGameState.activeEvent.health > 0) { 
                                let damageDealtThisHit = Math.min(localGameState.activeEvent.health, attackPower);
                                localGameState.activeEvent.health -= attackPower;
                                await triggerThreatDamageFlash(damageDealtThisHit);
                                _log(`Used ${usedCard.name} to deal ${attackPower} damage to ${localGameState.activeEvent.name}. (Attack ${i+1}/${attacks})`, 'action');
                                
                                if(localGameState.activeEvent.health <= 0) {
                                    const defeatedThreat = localGameState.activeEvent;
                                    _log(`${defeatedThreat.name} was defeated!`, 'system');
                                    
                                    if (defeatedThreat.id && defeatedThreat.id.startsWith('ai_boss_')) {
                                        localGameState.status = 'finished';
                                        localGameState.winReason = `You defeated ${defeatedThreat.name} and conquered the frontier!`;
                                        updateUIFromGameState(); 
                                        return; 
                                    }

                                    if (defeatedThreat.subType === 'human') {
                                        const bountyCard = { name: `${defeatedThreat.name} Bounty`, type: 'Bounty Proof', sellValue: defeatedThreat.goldValue, id: `bounty_${defeatedThreat.id}_${Date.now()}` };
                                        p.playerDiscard.push(bountyCard);
                                        _log(`You collect a bounty for the defeated ${defeatedThreat.name}.`, 'system');
                                    } else if (defeatedThreat.subType === 'animal') {
                                        const trophy = { name: `${defeatedThreat.name} Trophy`, type: 'Trophy', sellValue: defeatedThreat.goldValue, id: `trophy_${defeatedThreat.id}_${Date.now()}` };
                                        p.playerDiscard.push(trophy);
                                    } else { 
                                        localGameState.eventDiscardPile.push(defeatedThreat);
                                    }
                                    localGameState.activeEvent = null;
                                    break; 
                                }
                            } else { break; } 
                        }
                    } else if (attackPower > 0) {
                        _log(`Used ${usedCard.name}, but there's no target!`, 'action');
                    }
                    break;
                }
                case 'campfire':
                    p.isCampfireActive = true;
                    _log(`A campfire was built. It will keep you safe tonight.`, 'action');
                    break;
                 case 'gold': 
                    const goldAmount = usedCard.effect.amount || 0;
                    p.gold += goldAmount;
                    _log(`Used ${usedCard.name} to gain ${goldAmount} gold.`, 'gold');
                    triggerGoldFlash();
                    break;
                case 'trap':
                    if(p.activeTrap) { 
                        p.playerDiscard.push(p.activeTrap);
                        _log(`Replaced old ${p.activeTrap.name} with new ${usedCard.name}.`, 'system');
                    }
                    p.activeTrap = usedCard; 
                    _log(`Set a ${usedCard.name}.`, 'action');
                    updateUIFromGameState(); 
                    return; 
                case 'scout': {
                    const nextEvent = localGameState.eventDeck[localGameState.eventDeck.length - 1];
                    if (nextEvent) {
                        _log(`Scouting ahead... you see a ${nextEvent.name}.`, 'action');
                        await showScoutedCard(nextEvent); 
                    } else {
                        _log("Scouted ahead, but the event deck is empty.", 'system');
                    }
                    break;
                }
            }

            if(!usedCard.effect?.persistent && usedCard.effect?.type !== 'trap') {
                p.playerDiscard.push(usedCard);
            }
           
            updateUIFromGameState();
        }
       
        function handleSellItem(card, source, index) {
            const p = localGameState.playerDetails[playerId];
           
            const [soldCard] = p.hand.splice(index, 1);
            let goldGained = soldCard.sellValue || 0;

            if (p.equippedItems.some(i => i.id === 'upgrade_treasure_map')) { 
                goldGained += 2;
                _log("Treasure Map adds 2 extra gold to sale!", "system");
            }
            p.gold += goldGained;
            triggerGoldFlash();

            if(p.hand.length < p.handSize) { 
                if(p.playerDeck.length === 0 && p.playerDiscard.length > 0) {
                    _log("Reshuffling discard into deck to draw.", "system");
                    p.playerDeck = shuffleArray(p.playerDiscard);
                    p.playerDiscard = [];
                }
                if(p.playerDeck.length > 0) {
                    const drawnCard = p.playerDeck.pop();
                    p.hand.push(drawnCard);
                     _log(`Sold ${soldCard.name} for ${goldGained} gold and drew ${drawnCard.name}.`, 'gold');
                } else {
                    _log(`Sold ${soldCard.name} for ${goldGained} gold. Deck empty, no card drawn.`, 'gold');
                }
            } else {
                 _log(`Sold ${soldCard.name} for ${goldGained} gold. Hand full, no card drawn.`, 'gold');
            }
            
            p.hasTakenActionThisTurn = true;
            p.isUnsortedDraw = true; 
            updateUIFromGameState();
        }
       
        function handleBuyItem(card, index) {
            const p = localGameState.playerDetails[playerId];

            p.gold -= card.buyCost;
            if(p.hand.length < p.handSize) { 
                p.hand.push({...card}); 
            } else { 
                p.playerDiscard.push({...card});
                 _log(`Hand full. ${card.name} sent to discard.`, 'system');
            }
           
            if (localGameState.storeItemDeck.length > 0) {
                localGameState.storeDisplayItems[index] = localGameState.storeItemDeck.pop();
            } else {
                localGameState.storeDisplayItems[index] = null; 
            }
           
            _log(`Bought ${card.name} for ${card.buyCost} gold.`, 'gold');
            triggerGoldFlash();
            p.hasTakenActionThisTurn = true;
            p.isUnsortedDraw = true; 
            updateUIFromGameState();
        }
       
        function handleStoreProvision(card, index){
            const p = localGameState.playerDetails[playerId];
            const satchel = p.equippedItems.find(item => item.id === 'upgrade_satchel');
            if (!satchel) {
                _log("No satchel equipped to store provisions.", "error");
                return;
            }
            const satchelCapacity = satchel.effect.capacity || 3;

            if ((p.satchel?.length || 0) >= satchelCapacity) {
                 _log("Satchel is full!", "error");
                return;
            }

            const [provision] = p.hand.splice(index, 1);
            if(!p.satchel) p.satchel = [];
            p.satchel.push(provision);
            _log(`Stored ${provision.name} in satchel. Satchel: ${p.satchel.length}/${satchelCapacity}`, 'action');
            p.hasTakenActionThisTurn = true;
            updateUIFromGameState();
        }
       
        function handleUseFromSatchel() {
            const p = localGameState.playerDetails[playerId];

            if (!p.satchel || p.satchel.length === 0) {
                _log("Satchel is empty!", 'error');
                return;
            }

            const [usedCard] = p.satchel.splice(0, 1); 
           
            switch(usedCard.effect.type) {
                case 'heal': {
                    const healAmount = calculateHealAmount(usedCard, p);
                    const oldHealth = p.health;
                    p.health = Math.min(p.maxHealth, p.health + healAmount);
                    const actualHeal = p.health - oldHealth;
                    _log(`Used ${usedCard.name} from satchel to heal for ${actualHeal}.`, 'action');
                    if (actualHeal > 0) {
                        triggerHealFlash(actualHeal);
                    }
                     if (usedCard.effect.cures && localGameState.activeEvent && localGameState.activeEvent.subType === 'illness') {
                        _log(`${usedCard.name} cured the ${localGameState.activeEvent.name}!`, 'system');
                        localGameState.eventDiscardPile.push(localGameState.activeEvent);
                        localGameState.activeEvent = null;
                    }
                    break;
                }
            }
            p.playerDiscard.push(usedCard); 
           
            p.hasTakenActionThisTurn = true;
            updateUIFromGameState();
        }

        function handleDiscardEquippedItem(card, index) {
            const p = localGameState.playerDetails[playerId];
            const [discardedCard] = p.equippedItems.splice(index, 1);

            if (discardedCard) {
                if (discardedCard.effect?.subtype === 'max_health') {
                    p.maxHealth = Math.max(1, p.maxHealth - (discardedCard.effect.amount || 0));
                    if (p.health > p.maxHealth) p.health = p.maxHealth;
                }
                 if (discardedCard.id.includes('hat') && discardedCard.effect?.max_health) {
                     p.maxHealth = Math.max(1, p.maxHealth - (discardedCard.effect.max_health || 0));
                    if (p.health > p.maxHealth) p.health = p.maxHealth;
                }
                
                p.playerDiscard.push(discardedCard);
                
                if (discardedCard.id === 'upgrade_satchel') { 
                    if (p.satchel && p.satchel.length > 0) {
                        p.playerDiscard.push(...p.satchel);
                        _log(`Satchel discarded, ${p.satchel.length} provisions moved to discard pile.`, 'system');
                        p.satchel = [];
                    }
                }
                _log(`Discarded equipped item: ${discardedCard.name}.`, 'action');
            }
            
            p.hasTakenActionThisTurn = true;
            updateUIFromGameState();
        }

        function handleDiscardUpgrade(card, index) { 
            const p = localGameState.playerDetails[playerId];
            const [discardedCard] = p.equippedItems.splice(index, 1);

            if (discardedCard) {
                if (discardedCard.effect?.subtype === 'max_health') {
                    p.maxHealth = Math.max(1, p.maxHealth - (discardedCard.effect.amount || 0));
                    if (p.health > p.maxHealth) p.health = p.maxHealth;
                }
                 if (discardedCard.id.includes('hat') && discardedCard.effect?.max_health) {
                     p.maxHealth = Math.max(1, p.maxHealth - (discardedCard.effect.max_health || 0));
                    if (p.health > p.maxHealth) p.health = p.maxHealth;
                }
                
                p.playerDiscard.push(discardedCard);
                _log(`Discarded Player Upgrade: ${discardedCard.name}, losing its benefits.`, 'action');
            }
            
            p.hasTakenActionThisTurn = true;
            updateUIFromGameState();
        }

        function handleTakeEventItem(card) { 
            if (!localGameState || localGameState.status !== 'playing') return;

            const p = localGameState.playerDetails[playerId];

            if (p.hand.length < p.handSize) {
                p.hand.push({...card}); 
                _log(`Took ${card.name} and added it to hand.`, 'action');
            } else {
                p.playerDiscard.push({...card}); 
                _log(`Hand full. Took ${card.name} and added it to discard.`, 'action');
            }

            localGameState.eventDiscardPile.push(localGameState.activeEvent); 
            localGameState.activeEvent = null; 
            p.hasTakenActionThisTurn = true;
            p.isUnsortedDraw = true; 
            updateUIFromGameState();
        }
        
        async function handleRestockStore() {
            let state = localGameState;
            let p = state.playerDetails[playerId];
            if (p.hasRestockedThisTurn) {
                showModal("Too Late!", "You've already restocked the store this day.");
                return;
            }
            if (p.gold < 1) {
                showModal("Not Enough Gold!", "The clerk requires 1 gold to restock the shelves.");
                return;
            }

            p.gold -= 1;
            triggerGoldFlash();
            _log("You pay the clerk 1 gold to restock the shelves.", 'action');

            const currentItems = state.storeDisplayItems.filter(item => item !== null);
            state.storeItemDeck.unshift(...currentItems); 
            shuffleArray(state.storeItemDeck); 
            
            state.storeDisplayItems = [null, null, null]; 
            p.hasRestockedThisTurn = true;
            updateUIFromGameState(); 

            await delay(500); 

             for(let i=0; i < STORE_DISPLAY_LIMIT; i++) { 
                if (state.storeItemDeck.length > 0) {
                    state.storeDisplayItems[i] = state.storeItemDeck.pop();
                } else {
                    state.storeDisplayItems[i] = null; 
                }
            }
            _log("The clerk has restocked the shelves.", "system");
            updateUIFromGameState();
        }

        async function applyThreatEffect(threat, playerDetails, state) { 
            if (!threat || !threat.effect || threat.type !== 'Event') {
                if (threat && threat.type !== 'Event') {
                     _log(`You found a ${threat.name}! You can take it on your turn.`, 'system');
                }
                return; 
            }

            const effect = threat.effect;
            let damage = 0;
            let hadNegativeEffect = false;
            
            if(effect.type === 'damage' || effect.type === 'poison' || effect.type === 'conditional_damage') {
                damage = effect.amount || effect.damage || 0;
            } else if (effect.type === 'damage_percent') {
                damage = Math.floor(playerDetails.health * effect.amount);
            } else if (effect.type === 'lose_gold') {
                const stolenAmount = Math.min(playerDetails.gold, effect.amount || Math.floor(Math.random() * 5) + 1) ;
                playerDetails.gold -= stolenAmount;
                if (stolenAmount > 0) {
                    _log(`${threat.name} stole ${stolenAmount} gold from you!`, 'event');
                    triggerGoldFlash(); 
                    hadNegativeEffect = true;
                } else {
                     _log(`${threat.name} tried to steal gold, but your pockets are empty!`, 'event');
                }
            }

            let shouldEndTurnDueToEffect = effect.turn_end || false;

            if (effect.discard_equipped) {
                if (playerDetails.equippedItems.length > 0) {
                    _log(`${threat.name} forces you to discard equipped items!`, 'event');
                    let itemsToDiscard = [...playerDetails.equippedItems];
                    playerDetails.equippedItems = []; 
                    itemsToDiscard.forEach(item => {
                        if (item.id === 'upgrade_iron_will') { 
                             playerDetails.equippedItems.push(item);
                             _log("Your Iron Will holds strong!", "system");
                        } else {
                            if (item.effect?.subtype === 'max_health') playerDetails.maxHealth = Math.max(1, playerDetails.maxHealth - (item.effect.amount || 0));
                            if (item.id.includes('hat') && item.effect?.max_health) playerDetails.maxHealth = Math.max(1, playerDetails.maxHealth - (item.effect.max_health || 0));
                            playerDetails.playerDiscard.push(item);
                            hadNegativeEffect = true;
                        }
                    });
                    if (playerDetails.health > playerDetails.maxHealth) playerDetails.health = playerDetails.maxHealth;
                }
            }

            if (damage > 0) {
                dealPlayerDamage(playerDetails, damage, state, threat.name);
                hadNegativeEffect = true;
            }
            
            if (playerDetails.health <= 0) { 
                shouldEndTurnDueToEffect = false; 
            }
            
            if (shouldEndTurnDueToEffect && hadNegativeEffect) {
                playerDetails.wasDamagedOrNegativelyAffectedThisTurn = true;
            }

            if (shouldEndTurnDueToEffect && !threat.health && threat.type === 'Event') {
                _log(`${threat.name} dissipates after its effect.`, 'system');
                state.eventDiscardPile.push(threat);
                state.activeEvent = null;
            }


            updateUIFromGameState();

            if (shouldEndTurnDueToEffect && state.status !== 'finished') {
                triggerNaturalThreatText(threat.name);
                playerDetails.turnEnded = true; 
                ui.endTurnButton.disabled = true;
                setTimeout(() => {
                    if (localGameState.status !== 'finished') { 
                        endTurn();
                    }
                }, 1500); 
            }
        }
       
        function dealPlayerDamage(playerDetails, damage, state, sourceName) {
            let actualDamage = damage;

            const bible = playerDetails.equippedItems.find(item => item.id === 'upgrade_tattered_bible');
            if (bible) {
                actualDamage = Math.max(0, actualDamage - 1);
                if (damage > actualDamage) _log(`Your Tattered Bible reduces the damage by 1!`, 'system');
            }
            
            if (actualDamage > 0 && sourceName !== 'Rockslide' && sourceName !== 'Malaria' && sourceName !== 'Dysentery' && sourceName !== 'Snake Bite') { 
                 const equippedHats = playerDetails.equippedItems.filter(item => item.id.includes('hat') && item.effect?.subtype === 'damage_negation');
                
                if (equippedHats.length > 0) {
                     const hatToDiscard = equippedHats[0]; 
                     const hatIndex = playerDetails.equippedItems.findIndex(i => i.id === hatToDiscard.id);
                     if (hatIndex > -1) playerDetails.equippedItems.splice(hatIndex, 1);
                     
                     if (hatToDiscard.effect?.max_health) { 
                          playerDetails.maxHealth = Math.max(1, playerDetails.maxHealth - (hatToDiscard.effect.max_health || 0));
                          if (playerDetails.health > playerDetails.maxHealth) playerDetails.health = playerDetails.maxHealth;
                     }
                      playerDetails.playerDiscard.push(hatToDiscard);
                     _log(`Your ${hatToDiscard.name} was knocked off and absorbed all damage from ${sourceName}!`, 'system');
                     actualDamage = 0; 
                }
            }
           
            if (actualDamage > 0) {
                playerDetails.health -= actualDamage;
                _log(`${sourceName} deals ${actualDamage} damage!`, 'event');
                triggerDamageFlash(actualDamage); 
            } else if (damage > 0 && actualDamage === 0) {
                 _log(`Damage from ${sourceName} was fully negated!`, 'system');
            }


            if (playerDetails.health <= 0) {
                playerDetails.health = 0;
                state.status = 'finished';
                state.winReason = `Felled by ${sourceName}!`;
                _log(state.winReason, 'system');
            }
        }
       
        async function generateStory() { 
            if (!localGameState || !localGameState.log || localGameState.storyGenerated) return;

            let storyHasBeenSet = false;
            if (ui.storyModal.overlay) ui.storyModal.overlay.classList.remove('hidden');
            if (ui.storyModal.text) ui.storyModal.text.textContent = "Writing your legend...";

            if (!GEMINI_API_KEY || GEMINI_API_KEY === "AIzaSyCa7ymQSXzZuJbNbXB-xTVGZ0UqmFeCESo") { // User's existing key check
                if (ui.storyModal.text) ui.storyModal.text.textContent = "The storyteller is missing... (No API Key provided). Your tale remains untold, but your deeds are remembered.";
                return;
            }
           
            try {
                const logSummary = localGameState.log
                    .filter(entry => entry.type !== 'debug') 
                    .map(entry => `[${entry.type}] ${entry.message}`)
                    .slice(0, 150) 
                    .reverse() 
                    .join('\n');
               
                const adventurerName = localGameState.playerDetails[playerId].name;
                const character = localGameState.playerDetails[playerId].character;
                const characterDescription = character.storyDesc;

                const prompt = `You are a master storyteller of the Old West. Your task is to write a vivid and atmospheric tale about a lone adventurer.

                THE CHARACTER:
                Their name is ${adventurerName}. They are a known ${character.name}, described as: "${characterDescription}". Weave this physical description into the story naturally.
                
                THE TASK:
                Use the following game log to add specific details and give context to the events. Do not just list the events. Flesh them out with rich sensory details, focusing on a few key moments rather than trying to narrate every single log entry.
                - Describe the **environment**: Is it a sun-baked desert, a muddy, rain-slicked forest, or a freezing mountain pass? Is the air still or windy?
                - Describe the **character's state**: Mention their clothing, gear, weariness, determination, or specific feelings related to events.
                - Describe notable **threats or encounters**: Give them a memorable appearance or behavior.
                
                Make the reader *feel* the grit, the heat, and the tension of this journey. Conclude the story with their final outcome, as written in the log. Aim for a compelling narrative of around 3-5 paragraphs.

                KEY GAME LOG EVENTS:
                ${logSummary}
                
                FINAL OUTCOME: ${localGameState.winReason}`;

                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API request failed: ${response.status} ${errorText}`);
                }
                
                const result = await response.json();

                if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                    const text = result.candidates[0].content.parts[0].text;
                    if (ui.storyModal.text) ui.storyModal.text.textContent = text;
                    storyHasBeenSet = true;
                } else {
                   throw new Error("Could not generate a valid story from the API response.");
                }
                localGameState.storyGenerated = true;
            } catch (error) {
                console.error("Error generating story:", error);
                if (!storyHasBeenSet && ui.storyModal.text) {
                    ui.storyModal.text.textContent = "The ink ran dry... could not write your story. Your deeds will have to speak for themselves.";
                }
            }
        }

        async function generateAIBoss() { 
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "AIzaSyCa7ymQSXzZuJbNbXB-xTVGZ0UqmFeCESo") { // User's existing key check
                console.warn("No API key for AI Boss generation. Using a default boss.");
                return { name: 'The Nameless Dread', type: 'Event', subType: 'human', health: 25, goldValue: 50, effect: {type:'damage', amount: 15}, description: "A shadowy figure of legend, spoken of only in hushed whispers." };
            }
            _log("A great evil awakens in the west...", "system");
            try {
                const prompt = `Create a unique, pulp western-themed final boss for a card game. The boss should be a single person, entity, or creature from western folklore (e.g., wendigo, spectral gunslinger, haunted prospector, legendary beast, malevolent dust devil). Avoid high-fantasy like dragons. Provide its name, a one-paragraph atmospheric description of its lore/appearance, its health (integer between 20 and 35), and the damage it deals (integer between 10 and 18). Respond ONLY with a single, clean JSON object in the format: {"name": "Boss Name", "health": 25, "damage": 15, "description": "lore..."}`;
                const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }], generationConfig: { response_mime_type: "application/json" } }; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) throw new Error(`API request failed with status ${response.status}: ${await response.text()}`);
                const result = await response.json();
                
                let bossData;
                if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                    let text = result.candidates[0].content.parts[0].text;
                    const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/) || text.match(/(\{[\s\S]*\})/);
                    if (jsonMatch && jsonMatch[1]) {
                        bossData = JSON.parse(jsonMatch[1]);
                    } else if (jsonMatch && jsonMatch[0]) {
                         bossData = JSON.parse(jsonMatch[0]);
                    } else { 
                         bossData = JSON.parse(text);
                    }
                } else {
                     throw new Error("No valid content found in AI boss response.");
                }


                _log(`${bossData.name} has appeared!`, "event");

                return {
                    id: 'ai_boss_' + Date.now(),
                    name: bossData.name,
                    description: bossData.description,
                    type: 'Event',
                    subType: 'human', 
                    health: parseInt(bossData.health) || 25,
                    goldValue: (parseInt(bossData.health) || 25) * 2, 
                    effect: { type: 'damage', amount: parseInt(bossData.damage) || 15 }
                };

            } catch (error) {
                console.error("Error generating AI boss:", error);
                _log("Failed to generate a unique threat. A familiar foe appears instead.", "error");
                return { name: 'The Nameless Dread', type: 'Event', subType: 'human', health: 25, goldValue: 50, effect: {type:'damage', amount: 15}, description: "A shadowy figure of legend, spoken of only in hushed whispers." };
            }
        }
        
        async function remixCardsForNGPlus() { 
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "AIzaSyCa7ymQSXzZuJbNbXB-xTVGZ0UqmFeCESo") { // User's existing key check
                _log("Cannot remix cards for NG+ without an API Key. Using standard cards.", "error");
                return;
            }
            _log("The world feels... different. More dangerous. NG+ Remixing cards...", "system");
            try {
                const prompt = `You are a game designer. Here is a JSON object representing cards in a western-themed game: ${JSON.stringify(ALL_CARDS_DATA)}. The player has reached "New Game+ 10" or higher, so the cards must be remixed to be more difficult and legendary. Follow these rules precisely: \n1. For every single Threat card (type: 'Event'): \n   - If its subType is 'animal', change its 'name' to a more dangerous or mythical North American animal (e.g., 'Wolf' could become 'Dire Wolf', 'Bear' could become 'Kodiak Monstrosity').\n   - If its subType is 'human', change its 'name' to a mythological creature or infamous figure from a 'weird west' theme (e.g., 'Outlaw' could become 'Wendigo Stalker', 'Bandit' could become 'Skinwalker Renegade').\n   - If its subType is 'environmental' or 'illness', change its 'name' to a more severe or supernatural version (e.g., 'Rockslide' to 'Mountain's Wrath Avalanche', 'Malaria' to 'Swamp Spectre's Curse').\n   - Increase its 'health' (if present) by a factor of 1.5 to 2 (round to nearest integer) and its 'damage' or 'amount' in its effect (if damage related) by 2 to 5.\n2. For every 'weapon' card (effect.type: 'weapon'), add a random integer between 1 and 3 to its 'attack' value.\n3. For all other cards (Items, Provisions, Upgrades, Actions not covered above), give them a new, more epic-sounding 'name' (e.g., 'Small Meat' to 'Sustaining Jerky', 'Hat' to 'Stetson of Resilience') and rewrite their 'description' to be one evocative sentence that reflects their enhanced power or rarity.\nDo not change any other keys (like 'id', 'type', 'subType', 'effect.type' unless it's damage amount) or the fundamental effect of the cards beyond numerical adjustments for threats/weapons. Return ONLY the modified JSON object, ensure it is valid JSON.`;
                
                const payload = { 
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { response_mime_type: "application/json" } 
                };
                
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error(`API request failed with status ${response.status}: ${await response.text()}`);
                
                const result = await response.json();
                let text = result.candidates[0].content.parts[0].text;
                
                let remixedCards;
                const jsonMatch = text.match(/```json\s*([\s\S]*?)\s*```/) || text.match(/(\{[\s\S]*\})/);
                if (jsonMatch && jsonMatch[1]) {
                    remixedCards = JSON.parse(jsonMatch[1]);
                } else if (jsonMatch && jsonMatch[0]) {
                    remixedCards = JSON.parse(jsonMatch[0]);
                } else { 
                    remixedCards = JSON.parse(text);
                }

                Object.assign(ALL_CARDS_DATA, remixedCards); 
                _log("The very fabric of the frontier has been reforged by legend!", "system");

            } catch (error) {
                console.error("Error remixing cards:", error);
                 _log("The legends remain the same... for now. (Card remix failed)", "error");
            }
        }
        
        async function handleEndGameSequence(isVictory) {
            if (localGameState.status !== 'finished') localGameState.status = 'finished'; 

            const banner = ui.endGameBanner;
            const bannerText = ui.endGameText;
            const overlay = document.getElementById('endGameOverlay');

            banner.style.transitionDuration = '0s'; 
            overlay.style.transitionDuration = '0s';

            if (isVictory) {
                bannerText.textContent = "Victory!";
                bannerText.style.color = '#22c55e'; 
                overlay.style.opacity = '0.8'; 
                overlay.style.transitionDuration = '0.5s';
                
                banner.style.opacity = '1';
                banner.style.transitionDuration = '0.7s';
                await delay(2500); 
                banner.style.opacity = '0';
                await delay(700); 
                overlay.style.opacity = '0'; 
                await delay(500);

            } else { 
                overlay.style.opacity = '1'; 
                overlay.style.transitionDuration = '1.5s'; 
                await delay(1500); 
                
                bannerText.textContent = "You Died";
                bannerText.style.color = '#ef4444'; 
                banner.style.opacity = '1';
                banner.style.transitionDuration = '1s'; 
                await delay(1500); 
                banner.style.opacity = '0';
                banner.style.transitionDuration = '0.5s'; 
                await delay(500); 
            }
            
            if (isVictory) {
                if(localGameState.activeEvent?.id?.startsWith('ai_boss_')) { 
                    localGameState.playerDetails[playerId].gold += localGameState.activeEvent.goldValue || 0;
                }
                const deckToSave = {
                    deck: localGameState.playerDetails[playerId].playerDeck.map(c => c.id),
                    discard: localGameState.playerDetails[playerId].playerDiscard.map(c => c.id),
                    hand: localGameState.playerDetails[playerId].hand.map(c => c.id),
                    equipped: localGameState.playerDetails[playerId].equippedItems.map(c => c.id)
                };
                localStorage.setItem('wildWestWinDeck', JSON.stringify(deckToSave));
                let ngPlusLevel = parseInt(localStorage.getItem('ngPlusLevel') || '0');
                ngPlusLevel++;
                localStorage.setItem('ngPlusLevel', ngPlusLevel.toString());
                _log(`Your deck has been saved! Preparing for New Game+ ${ngPlusLevel}...`, "system");
                ui.storyModal.closeButton.textContent = `Begin NG+ ${ngPlusLevel}`;
            } else { 
                 localStorage.removeItem('wildWestWinDeck'); 
                 localStorage.setItem('ngPlusLevel', '0'); 
                 ui.storyModal.closeButton.textContent = "Try Again";
            }
            
            deselectAllCards();

            if(!localGameState.storyGenerated) {
                await generateStory();
            } else { 
                 ui.storyModal.overlay.classList.remove('hidden');
            }
        }
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
